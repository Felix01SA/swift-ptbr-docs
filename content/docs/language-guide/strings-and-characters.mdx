---
title: Strings e Caracteres
description: Cada letra √© uma estrela, e juntas brilham no c√≥digo ‚ú®
---

import { SubstringExemple } from "@/components/substring-example";
import {
  UTF8RepresentationExemple,
  UTF16RepresentationExemple,
  UnicodeScalarRepresentationExemple,
} from "@/components/utf-representation-exemple";

Uma _string_ √© uma s√©rie de caracteres, como `"ol√°, mundo"` ou `"albatroz"`. As strings Swift s√£o representadas pelo tipo de `String`. O conte√∫do de uma `String` pode ser acessado de v√°rias maneiras, inclusive como uma cole√ß√£o de valores de caracteres.

Os tipos de `String` e `Character` do Swift fornecem uma maneira r√°pida e compat√≠vel com Unicode de trabalhar com texto em seu c√≥digo. A sintaxe para cria√ß√£o e manipula√ß√£o de strings √© leve e leg√≠vel, com uma sintaxe literal de string semelhante a C. A concatena√ß√£o de strings √© t√£o simples quanto combinar duas strings com o operador `+`, e a mutabilidade de strings √© gerenciada escolhendo entre uma constante ou uma vari√°vel, assim como qualquer outro valor no Swift. Voc√™ tamb√©m pode usar strings para inserir constantes, vari√°veis, literais e express√µes em strings mais longas, em um processo conhecido como interpola√ß√£o de strings. Isso facilita a cria√ß√£o de valores de string personalizados para exibi√ß√£o, armazenamento e impress√£o.

Apesar dessa simplicidade de sintaxe, o tipo de string do Swift √© uma implementa√ß√£o de string r√°pida e moderna. Cada string √© composta por caracteres Unicode independentes de codifica√ß√£o e fornece suporte para acessar esses caracteres em v√°rias representa√ß√µes Unicode.

<Callout title="Nota">
O tipo String do Swift √© conectado √† classe NSString da Foundation. A Foundation tamb√©m estende o String para expor os m√©todos definidos pelo `NSString. Isso significa que, se voc√™ importar a Funda√ß√£o, poder√° acessar esses m√©todos `NSString no String sem fundi√ß√£o.

Para obter mais informa√ß√µes sobre como usar String com Foundation e Cocoa, consulte Bridging Between String e [`NSString](https://developer.apple.com/documentation/swift/string#2919514).

</Callout>

## Strings Literais [#string-literals]

Voc√™ pode incluir valores de String predefinidos dentro do seu c√≥digo como literais de string. Uma _string literal_ √© uma sequ√™ncia de caracteres cercada por aspas duplas (`"`).

Use uma string literal como um valor inicial para uma constante ou vari√°vel:

```swift
let someString = "Algum valor literal de string"
```

Observe que o Swift infere um tipo de `String` para a constante `someString` porque √© inicializado com um valor literal de string.

### Strings Literais multilinhas [#multiline-string-literals]

Se voc√™ precisar de uma string que se estende por v√°rias linhas, use uma string literal de v√°rias linhas - uma sequ√™ncia de caracteres cercada por tr√™s aspas duplas:

```swift lineNumbers
let quotation = """
O Coelho Branco colocou seus √≥culos. "Onde devo come√ßar,

Por favor, sua Majestade?" Ele perguntou.

"Comece no come√ßo", disse o Rei severamente, "e siga em frente

At√© voc√™ chegar ao fim; ent√£o pare."
"""
```

Um literal de string de v√°rias linhas inclui todas as linhas entre aspas de abertura e fechamento. A string come√ßa na primeira linha ap√≥s as aspas de abertura (`"""`) e termina na linha antes das aspas de fechamento, o que significa que nenhuma das strings abaixo come√ßa ou termina com uma quebra de linha:

```swift
let singleLineString = "Estes s√£o os mesmos."
let multilineString = """
Estes s√£o os mesmos.
"""
```

Quando seu c√≥digo-fonte inclui uma quebra de linha dentro de uma string literal de v√°rias linhas, essa quebra de linha tamb√©m aparece no valor da string. Se voc√™ quiser usar quebras de linha para tornar seu c√≥digo-fonte mais f√°cil de ler, mas n√£o quiser que as quebras de linha fa√ßam parte do valor da string, escreva uma barra invertida (`\`) no final dessas linhas:

```swift lineNumbers
let softWrappedQuotation = """
O Coelho Branco colocou seus √≥culos. "Onde devo come√ßar, \

Por favor, sua Majestade?" Ele perguntou.

"Comece do come√ßo", disse o Rei severamente, "e siga em fra \

At√© voc√™ chegar ao fim; ent√£o pare."
"""
```

Para fazer uma string literal de v√°rias linhas que come√ßa ou termina com um feed de linha, escreva uma linha em branco como a primeira ou √∫ltima linha. Por exemplo:

```swift lineNumbers
let lineBreaks = """

Esta corda come√ßa com uma quebra de linha.
Tamb√©m termina com uma quebra de linha.

"""
```

Uma string de v√°rias linhas pode ser retida para corresponder ao c√≥digo ao redor. O espa√ßo em branco antes das aspas de fechamento (`"""`) diz a Swift qual espa√ßo em branco ignorar antes de todas as outras linhas. No entanto, se voc√™ escrever espa√ßo em branco no in√≠cio de uma linha al√©m do que est√° antes das aspas de fechamento, esse espa√ßo em branco ser√° inclu√≠do.

![String whitespace example](/string-whitespace-exemple.png)

No exemplo acima, mesmo que todo o literal da string de v√°rias linhas esteja redentado, a primeira e a √∫ltima linhas da string n√£o come√ßam com nenhum espa√ßo em branco. A linha do meio tem mais recuo do que as aspas de fechamento, ent√£o come√ßa com esse recuo extra de quatro espa√ßos.

### Caracteres Especiais em String Literais [#special-characters-in-string-literals]

Os literais de string podem incluir os seguintes caracteres especiais:

{/* \0 (caractere nulo), \\ (barra invertida), \t (guia horizontal), \n (alimenta√ß√£o de linha), \r (retorno de carro), \" (aspas duplas) e \' (aspas simples) */}

| Caractere | Descri√ß√£o         | Tipo               |
| --------- | ----------------- | ------------------ |
| `\0`      | Caractere nulo    | Especial de escape |
| `\\`      | Barra Invertida   | Especial de escape |
| `\t`      | Guia horizontal   | Especial de escape |
| `\n`      | Nova linha        | Especial de escape |
| `\r`      | Retorno carro     | Especial de escape |
| `\"`      | Aspas duplas      | Especial de escape |
| `\'`      | Aspas simples     | Especial de escape |
| `\uXXXX'` | Caractere Unicode | Unicode arbitr√°rio |

Um valor escalar Unicode arbitr√°rio, escrito como `\u{n}`, onde `n` √© um n√∫mero hexadecimal de 1 a 8 d√≠gitos (**Unicode √© discutido em [Unicode](/docs/laanguage-guide/string-and-character#unicode) abaixo**)

O c√≥digo abaixo mostra quatro exemplos desses caracteres especiais. A constante `wiseWords` cont√©m duas aspas duplas escapadas. As constantes `dollarSign`, `blackHeart` e `sparklingHeart` demonstram o formato escalar Unicode:

```swift lineNumbers
let wiseWords = "\"A imagina√ß√£o √© mais importante do que o conhecimento\" - Einstein" // "A imagina√ß√£o √© mais importante do que o conhecimento" - Einstein
let dollarSign = "\u{24}" // $, Unicode escalar U+0024
let blackHeart = "\u{2665}" // ‚ô•, Unicode escalar U+2665
let sparklingHeart = "\u{1F496}" // üíñ, Unicode escalar U+1F496
```

Como os literais de string de v√°rias linhas usam tr√™s aspas duplas em vez de apenas uma, voc√™ pode incluir uma aspa dupla (`"`) dentro de uma string literal de v√°rias linhas sem escapar dela. Para incluir o texto `"""` em uma string de v√°rias linhas, escape de pelo menos uma das aspas. Por exemplo:

```swift lineNumbers
let threeDoubleQuotationMarks = """
Escapando a primeira aspas \"""
Escapando de todas as tr√™s aspas \"\"\"
"""
```

### Delimitadores de String Estendidos [#extends-string-delimiters]

Voc√™ pode colocar uma string literal dentro de _delimitadores estendidos_ para incluir caracteres especiais em uma string sem invocar seu efeito. Voc√™ coloca sua string entre aspas (`"`) e a envolve com sinais num√©ricos (`#`). Por exemplo, imprimir a string literal `#"Line 1\nLine 2"#{:swift}` imprime a sequ√™ncia de escape de alimenta√ß√£o de linha (`\n`) em vez de imprimir a string em duas linhas.

Se voc√™ precisar dos efeitos especiais de um caractere em uma string literal, combine o n√∫mero de sinais num√©ricos dentro da string seguindo o caractere de escape (`\`). Por exemplo, se sua string for `#"Line 1\nLine 2"#` e voc√™ quiser quebrar a linha, voc√™ pode usar `#"Line 1\#nLine 2"#` em vez disso. Da mesma forma, `###"Line1\###nLine2"###` tamb√©m quebra a linha.

Os literais de string criados usando delimitadores estendidos tamb√©m podem ser literais de string de v√°rias linhas. Voc√™ pode usar delimitadores estendidos para incluir o texto `"""` em uma string de v√°rias linhas, substituindo o comportamento padr√£o que termina o literal. Por exemplo:

```swift
let threeMoreDoubleQuotationMarks = #"""
Aqui est√£o mais tr√™s cita√ß√µes duplas: """
"""#
```

## Inicializando uma String vazia [#initializing-an-empty-string]

Para criar um valor de String vazio como ponto de partida para a constru√ß√£o de uma string mais longa, atribua uma string literal vazia a uma vari√°vel ou inicialize uma nova inst√¢ncia de String com a sintaxe do inicializador:

```swift
var emptyString = "" // String literal vazio
var anotherEmptyString = String() // syntax do inicializador
// Essas duas strings est√£o vazias e s√£o equivalentes uma √† outra
```

Descubra se um valor de String est√° vazio verificando sua propriedade Boolean `isEmpty`:

```swift
if emptyString.isEmpty {
  print("Nada para ver aqui.")
}
```

## Mutabilidade de Strings [#string-mutability]

Voc√™ indica se uma String espec√≠fica pode ser modificada (ou _mutada_) atribuindo-a a uma vari√°vel (nesse caso, pode ser modificada) ou a uma constante (caso em que n√£o pode ser modificada):

```swift lineNumbers
var variableString = "Cavalo"
variableString += " e carro√ßa"
// variableString agora √© "Cavalo e carro√ßa"

let constantString = "Batman"
constantString += " e outro Batman"
// Isso relata um erro de tempo de compila√ß√£o - uma string constante n√£o pode ser modificada
```

<Callout title="Nota">
  Essa abordagem √© diferente da muta√ß√£o de strings em Objective-C e Cocoa, onde
  voc√™ escolhe entre duas classes (`NSString` e `NSMutableString`) para indicar
  se uma string pode ser mutada.
</Callout>

## Strings s√£o tipos de valores [#string-are-value-types]

O tipo de String de Swift √© um tipo de valor. Se voc√™ criar um novo valor de String, esse valor de String ser√° copiado quando for passado para uma fun√ß√£o ou m√©todo, ou quando for atribu√≠do a uma constante ou vari√°vel. Em cada caso, uma nova c√≥pia do valor String existente √© criada, e a nova c√≥pia √© passada ou atribu√≠da, n√£o a vers√£o original. Os tipos de valor s√£o descritos em [Estruturas e Enumera√ß√£o S√£o Tipos de Valor](/docs/language-guide/structures-and-classes#structures-and-enumerations-are-value-types).

O comportamento de String de _c√≥pia por padr√£o_ do Swift garante que, quando uma fun√ß√£o ou m√©todo lhe passa um valor de String, fica claro que voc√™ possui esse valor de String exato, independentemente de onde ele veio. Voc√™ pode ter certeza de que a string que voc√™ passou n√£o ser√° modificada, a menos que voc√™ mesmo a modifique.

Nos bastidores, o compilador da Swift otimiza o uso de strings para que a c√≥pia real ocorra apenas quando for absolutamente necess√°rio. Isso significa que voc√™ sempre obt√©m um √≥timo desempenho ao trabalhar com strings como tipos de valor.

## Trabalhando com Caracteres [#working-with-characters]

Voc√™ pode acessar os valores de caracteres individuais para uma String iterando sobre a string com um loop `for-in`:

```swift lineNumbers
// [!code focus:3]
for character in "Gelo!ü•∂" {
  print(character)
}
// G
// e
// l
// o
// !
// ü•∂
```

O loop `for-in` √© descrito em [For-In Loops](/docs/language-guide/control-flow#for-in-loops).

Alternativamente, voc√™ pode criar uma constante ou vari√°vel de `Character` independente a partir de uma string literal de caractere √∫nico, fornecendo uma anota√ß√£o de tipo de caractere:

```swift
let exclamationMark: Character = "!"
```

Os valores de string podem ser constru√≠dos passando uma matriz de valores de caracteres como um argumento para seu inicializador:

```swift
let catCharacters: [Character] = ["G", "a", "t", "o", "!", "üê±"]
let catString = String(catCharacters)
print(catString) // "Gato!üê±"
```

## Concatenando Strings e Caracteres [#concatenation-string-and-characters]

Os valores de String podem ser adicionados (ou _concatenados_) com o operador de adi√ß√£o (`+`) para criar um novo valor de String:

```swift lineNumbers
let string1 = "Ol√°"
let string2 = " pessoal"
var welcome = string1 + string2
// welcome agora √© igual a "Ol√° pessoal"
```

Voc√™ tamb√©m pode anexar um valor de String a uma vari√°vel de String existente com o operador de atribui√ß√£o de adi√ß√£o (`+=`):

```swift
var instruction = "olhe para frente"
instruction += string2
// instruction agora √© igual a "olhe para frente pessoal"
```

Voc√™ pode anexar um valor de Caractere a uma vari√°vel String com o m√©todo `append(){:swift}` do tipo String:

```swift
let exclamationMark: Character = "!"
welcome.append(exclamationMark)
// welcome agora √© igual a "Ol√° mundo!"
```

<Callout title="Nota">
  Voc√™ n√£o pode anexar uma String ou Caractere a uma vari√°vel de Caractere
  existente, porque um valor de Caractere deve conter apenas um √∫nico caractere.
</Callout>

Se voc√™ estiver usando literais de string de v√°rias linhas para construir as linhas de uma string mais longa, voc√™ deseja que cada linha da string termine com uma quebra de linha, incluindo a √∫ltima linha. Por exemplo:

```swift lineNumbers
let badStart = """
um
dois
"""

let end = """
tr√™s
"""

print(badStart + end)
// Retorna 2 linhas:
// um
// doistr√™s

let goodStart = """
um
dois

"""

print(goodStart + end)
// Retorna 3 linas:
// um
// dois
// tr√™s
```

No c√≥digo acima, a concatena√ß√£o do `badStart` com o fim produz uma string de duas linhas, que n√£o √© o resultado desejado. Como a √∫ltima linha de `badStart` n√£o termina com uma quebra de linha, essa linha √© combinada com a primeira linha de fim. Em contraste, ambas as linhas de `goodStart` terminam com uma quebra de linha, portanto, quando combinadas com `end`, o resultado tem tr√™s linhas, como esperado.

## Interpola√ß√£o de Strings [#string-interpolation]

A _interpola√ß√£o de string_ √© uma maneira de construir um novo valor de string a partir de uma mistura de constantes, vari√°veis, literais e express√µes, incluindo seus valores dentro de um literal de string. Voc√™ pode usar a interpola√ß√£o de strings em literais de string de linha √∫nica e multilinha. Cada item que voc√™ insere no literal de string √© envolvido em um par de par√™nteses, prefixado por uma barra invertida (`\`):

```swift
let multiplier = 3
let message = "\(multiplier) vezes 2.5 √© \(Double(multiplier) * 2.5)"
// message √© "3 vezes 2.5 √© 7.5"
```

No exemplo acima, o valor do multiplicador √© inserido em uma string literal como `\(multiplicador)`. Este espa√ßo reservado √© substitu√≠do pelo valor real do multiplicador quando a interpola√ß√£o da string √© avaliada para criar uma string real.

O valor do multiplicador tamb√©m faz parte de uma express√£o maior mais tarde na string. Esta express√£o calcula o valor de `Double(multiplier) * 2,5` e insere o resultado (7,5) na string. Neste caso, a express√£o √© escrita como `\(Double(multiplier) * 2.5)` quando est√° inclu√≠da dentro do literal da string.

Voc√™ pode usar delimitadores de string estendidos para criar strings contendo caracteres que, de outra forma, seriam tratados como uma interpola√ß√£o de strings. Por exemplo:

```swift
print(#"Escreva uma string interpolada em Swift usando \(multiplier)."#)
// "Escreva uma string interpolada em Swift usando \(multiplier)."
```

Para usar a interpola√ß√£o de strings dentro de uma string que usa delimitadores estendidos, combine o n√∫mero de sinais num√©ricos ap√≥s a barra invertida com o n√∫mero de sinais num√©ricos no in√≠cio e no final da string. Por exemplo:

```swift
print(#"6 vezes 7 √© \#(6 * 7)."#)
// 6 vezes 7 √© 42
```

<Callout title="Nota">
  As express√µes que voc√™ escreve dentro de par√™nteses dentro de uma string
  interpolada n√£o podem conter uma barra invertida sem escape (`\`), um retorno
  de carro ou um feed de linha. No entanto, eles podem conter outros literais de
  string.
</Callout>

## Unicode [#unicode]

_Unicode_ √© um padr√£o internacional para codificar, representar e processar texto em diferentes sistemas de escrita. Ele permite que voc√™ represente quase qualquer caractere de qualquer idioma em uma forma padronizada e leia e escreva esses caracteres para e de uma fonte externa, como um arquivo de texto ou p√°gina da web. Os tipos de String e Caractere do Swift s√£o totalmente compat√≠veis com Unicode, conforme descrito nesta se√ß√£o.

### Valores Escalares Unicode

Nos bastidores, o tipo de String nativo do Swift √© constru√≠do a partir de valores escalares _Unicode_. Um valor escalar Unicode √© um n√∫mero exclusivo de 21 bits para um caractere ou modificador, como `U+0061` para _LATIN SMALL LETTER A_ ("a"), ou `U+1F425` para _FRONT-FACING BABY CHICK_ ("üê•").

Observe que nem todos os valores escalares Unicode de 21 bits s√£o atribu√≠dos a um caractere - alguns escalares s√£o reservados para atribui√ß√£o futura ou para uso na codifica√ß√£o UTF-16. Os valores escalares que foram atribu√≠dos a um caractere normalmente tamb√©m t√™m um nome, como _LATIN SMALL LETTER A_ e _FRONT-FACING BABY CHICK_ nos exemplos acima.

### Clusters de Grafema Estendidos [#extended-grapheme-clusters]

Cada inst√¢ncia do tipo de `Character` de Swift representa um √∫nico _cluster de grafema estendido_. Um cluster de grafema estendido √© uma sequ√™ncia de um ou mais escalares Unicode que (quando combinados) produzem um √∫nico caractere leg√≠vel por humanos.

Aqui est√° um exemplo. A letra √© pode ser representada como o √∫nico escalar Unicode √© (_LETRA MIN√öSCULA LATINA E COM AGUDO_, ou `U+00E9`). No entanto, a mesma letra tamb√©m pode ser representada como um par de escalares‚Äîuma letra padr√£o e (_LATIN SMALL LETTER E_, ou `U+0065`), seguida pelo escalar _COMBINING ACUTE ACCENT_ (`U+0301`). O escalar _COMBINING ACUTE ACCENT_ √© aplicado graficamente ao escalar que o precede, transformando um e em um √© quando √© renderizado por um sistema de renderiza√ß√£o de texto com conhecimento de Unicode.

Em ambos os casos, a letra √© representada como um √∫nico valor de `Character` Swift que representa um cluster de grafema estendido. No primeiro caso, o cluster cont√©m um √∫nico escalar; no segundo caso, √© um cluster de dois escalares:

```swift
let eAcute: Character = "\u{E9}" // √©
let combinedEAcute: Character = "\u{65}\u{301}" // e seguido por  ÃÅ
// eAcute √© "√©", combinedEAcute √© "√©"
```

Clusters de grafema estendidos s√£o uma maneira flex√≠vel de representar muitos caracteres de script complexos como um √∫nico valor de caractere. Por exemplo, as s√≠labas Hangul do alfabeto coreano podem ser representadas como uma sequ√™ncia pr√©-composta ou decomposta. Ambas as representa√ß√µes se qualificam como um √∫nico valor de `Character` no Swift:

```swift
let precomposed: Character = "\u{D55C}" // Ìïú
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}" // ·Ñí, ·Ö°, ·Ü´
// precomposed √© Ìïú, decomposed √© Ìïú
```

Clusters de grafemas estendidos permitem escalares para incluir marcas (como `COMBINING ENCLOSING CIRCLE` ou `U+20DD`) para incluir outros escalares Unicode como parte de um √∫nico valor de Caractere:

```swift
let enclosedEAcute: Character = "\u{E9}\u{20DD}" // √©‚Éù
```

Escalares Unicode para s√≠mbolos indicadores regionais podem ser combinados em pares para criar um √∫nico valor de Caractere, como esta combina√ß√£o de _REGIONAL INDICATOR SYMBOL LETTER U_ (`U+1F1F1FA`) e _REGIONAL INDICATOR SYMBOL LETTER S_ (`U+1F1F8`):

```swift
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}"
// regionalIndicatorForUS √© üá∫üá∏
```

## Contando Caracteres [#count-characters]

Para recuperar uma contagem dos valores de caracteres em uma string, use a propriedade `count` da string:

```swift
let unusualMenagerie = "Coala üê®, Caracol üêå, Pinguim üêß, Dromed√°rio üê™"
print("unusualMenagerie tem \(unusualMenagerie.count) caracteres")
// unusualMenagerie tem 43 caracteres
```

Observe que o uso de clusters de grafemas estendidos por Swift para valores de caracteres significa que a concatena√ß√£o e modifica√ß√£o de strings nem sempre podem afetar a contagem de caracteres de uma string.

Por exemplo, se voc√™ inicializar uma nova string com a palavra `cafe` de quatro caracteres e, em seguida, anexar um _COMBINING ACUTE ACCENT_ (`U+0301`) ao final da string, a string resultante ainda ter√° uma contagem de caracteres de 4, com um quarto caractere de √©, n√£o e:

```swift lineNumbers
var word = "cafe"
print("O numero de caracteres na palavra \(word) √© \(word.count)")
// O numero de caracteres na palavra cafe √© 4

word += "\u{301}" // COMBINING ACUTE ACCENT, U+0301

print("O numero de caracteres na palavra \(word) √© \(word.count)")
// O numero de caracteres na palavra cafe √© 4
```

<Callout title="Nota">
Os clusters de grafemas estendidos podem ser compostos de v√°rios escalares Unicode. Isso significa que diferentes caracteres - e diferentes representa√ß√µes do mesmo caractere - podem exigir diferentes quantidades de mem√≥ria para armazenar. Por causa disso, os caracteres no Swift n√£o ocupam a mesma quantidade de mem√≥ria dentro da representa√ß√£o de uma string. Como resultado, o n√∫mero de caracteres em uma string n√£o pode ser calculado sem iterar atrav√©s da string para determinar seus limites de cluster de grafema estendidos. Se voc√™ estiver trabalhando com valores de string particularmente longos, esteja ciente de que a propriedade de contagem deve iterar sobre os escalares Unicode em toda a string para determinar os caracteres dessa string.

A contagem de caracteres retornados pela propriedade count nem sempre √© a mesma que a propriedade length de uma NSString que cont√©m os mesmos caracteres. O comprimento de uma NSString √© baseado no n√∫mero de unidades de c√≥digo de 16 bits dentro da representa√ß√£o UTF-16 da string e n√£o no n√∫mero de clusters de grafema estendidos Unicode dentro da string.

</Callout>

## Acessando e Modificando uma String [#accessing-and-modifying-a-string]

Voc√™ acessa e modifica uma string atrav√©s de seus m√©todos e propriedades, ou usando a sintaxe de subscrito.

### √çndices de string [#string-indices]

Cada valor de String tem um _tipo de √≠ndice_ associado, `String.Index`, que corresponde √† posi√ß√£o de cada Caractere na string.

Como mencionado acima, caracteres diferentes podem exigir diferentes quantidades de mem√≥ria para armazenar, portanto, para determinar qual Caractere est√° em uma posi√ß√£o espec√≠fica, voc√™ deve iterar sobre cada escalar Unicode a partir do in√≠cio ou do final dessa String. Por esse motivo, as strings Swift n√£o podem ser indexadas por valores inteiros.

Use a propriedade `startIndex` para acessar a posi√ß√£o do primeiro Caractere de uma String. A propriedade `endIndex` √© a posi√ß√£o ap√≥s o √∫ltimo caractere em uma String. Como resultado, a propriedade `endIndex` n√£o √© um argumento v√°lido para o subscrito de uma string. Se uma String estiver vazia, `startIndex` e `endIndex` ser√£o iguais.

Voc√™ acessa os √≠ndices antes e depois de um determinado √≠ndice usando os m√©todos `index(before:){:swift}` e `index(after:){:swift}` de String. Para acessar um √≠ndice mais distante do √≠ndice fornecido, voc√™ pode usar o m√©todo `index(_:offsetBy:){:swift}` em vez de chamar um desses m√©todos v√°rias vezes.

Voc√™ pode usar a sintaxe de subscrito para acessar o Caractere em um determinado √≠ndice de String.

```swift lineNumbers
let greeting = "Boa tarde!"
greeting[greeting.startIndex] // B
greeting[greeting.endIndex] // !

let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index] // d
```

Tentar acessar um √≠ndice fora do intervalo de uma string ou um Caractere em um √≠ndice fora do intervalo de uma string acionar√° um erro de tempo de execu√ß√£o.

```swift
greeting[greeting.endIndex] // Error
greeting.index(after: greeting.endIndex) // Error
```

Use a propriedade de `indices` para acessar todos os √≠ndices de caracteres individuais em uma string.

```swift
for index in greeting.indices {
  print("\(greeting[index]) ", terminator: "") // B o a  t a r d e !
}
```

<Callout title="Nota">
Voc√™ pode usar as propriedades `startIndex` e `endIndex` e os m√©todos `index(before:){:swift}`, `index(after:){:swift}` e `index(_:offsetBy:){:swift}` em qualquer tipo que esteja em conformidade com o protocolo `Collection`. Isso inclui String, como mostrado aqui, bem como tipos de cole√ß√£o, como Array, Dictionary e Set.
</Callout>

### Inser√ß√£o e remo√ß√£o [#insert-and-removing]

O insira um √∫nico caractere em uma string em um √≠ndice especificado, use o m√©todo `insert(_:at:){:swift}` e para inserir o conte√∫do de outra string em um √≠ndice especificado, use o m√©todo `insert(contentsOf:at:){:swift}`.

```swift lineNumbers
var welcome = "Ol√°"
welcome.insert("!", at: welcome.endIndex)
// welcome agora √© igual a "Ol√°!"

welcome.insert(contentsOf: " pessoal", at: welcome.index(before: welcome.endIndex))
// welcome agora √© "Ol√° pessoal!"
```

Para remover um √∫nico caractere de uma string em um √≠ndice especificado, use o m√©todo `remove(at:){:swift}` e para remover uma substring em um intervalo especificado, use o m√©todo `removeSubrange(_:){:swift}`:

```swift lineNumbers
welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome agora √© "Ol√° pessoal"

let range = welcome.index(welcome.endIndex, offsetBy: -8)..<welcome.endIndex
welcome.removeSubrange(range)
// welcome agora √© "Ol√°"
```

<Callout title="Nota">
Voc√™ pode usar os m√©todos `insert(_:at:){:swift}`, `insert(contentsOf:at:){:swift}`, `remove(at:){:swift}` e `removeSubrange(_:){:swift}` em qualquer tipo que esteja em conformidade com o protocolo `RangeReplaceableCollection`. Isso inclui String, como mostrado aqui, bem como tipos de cole√ß√£o, como Array, Dictionary e Set.
</Callout>

## Substrings [#substrings]

Quando voc√™ obt√©m uma substring de uma string, por exemplo, usando um subscrito ou um m√©todo como `prefix(_:){:swift}` o resultado √© uma inst√¢ncia de [Substring](https://developer.apple.com/documentation/swift/substring), n√£o outra string. Substrings no Swift t√™m a maioria dos mesmos m√©todos que strings, o que significa que voc√™ pode trabalhar com substrings da mesma forma que trabalha com strings. No entanto, ao contr√°rio das strings, voc√™ usa substrings por apenas um curto per√≠odo de tempo enquanto executa a√ß√µes em uma string. Quando voc√™ estiver pronto para armazenar o resultado por mais tempo, voc√™ converte a substring em uma inst√¢ncia de String. Por exemplo:

```swift lineNumbers
let greeting = "Ol√°, mundo!"
let index = greeting.firstIndex(of: ",") ?? greeting.endIndex
let beginning = greeting[..<index]
// beginning √© "Ol√°"

// Converta o resultado em uma String para armazenamento a longo prazo
let newString = String(beginning)
```

Como strings, cada substring tem uma regi√£o de mem√≥ria onde os caracteres que comp√µem a substring s√£o armazenados. A diferen√ßa entre strings e substrings √© que, como uma otimiza√ß√£o de desempenho, uma substring pode reutilizar parte da mem√≥ria que √© usada para armazenar a string original ou parte da mem√≥ria que √© usada para armazenar outra substring. (As strings t√™m uma otimiza√ß√£o semelhante, mas se duas strings compartilharem mem√≥ria, elas s√£o iguais.) Essa otimiza√ß√£o de desempenho significa que voc√™ n√£o precisa pagar o custo de desempenho de copiar a mem√≥ria at√© modificar a string ou a substring. Como mencionado acima, as substrings n√£o s√£o adequadas para armazenamento a longo prazo‚Äîporque reutilizam o armazenamento da string original, toda a string original deve ser mantida na mem√≥ria enquanto qualquer uma de suas substrings estiver sendo usada.

No exemplo acima, a `greeting` √© uma string, o que significa que tem uma regi√£o de mem√≥ria onde os caracteres que comp√µem a string s√£o armazenados. Como o in√≠cio √© uma substring da `greeting`, ele reutiliza a mem√≥ria que a `greeting` usa. Em contraste, `newString` √© uma string quando √© criada a partir da substring, ela tem seu pr√≥prio armazenamento. A figura abaixo mostra essas rela√ß√µes:

<SubstringExemple />

<Callout title="Nota">
  Tanto a String quanto a Substring est√£o em conformidade com o protocolo
  [`StringProtocol`](https://developer.apple.com/documentation/swift/stringprotocol),
  o que significa que geralmente √© conveniente para as fun√ß√µes de manipula√ß√£o de
  string aceitarem um valor `StringProtocol`. Voc√™ pode chamar essas fun√ß√µes com
  um valor de String ou Substring.
</Callout>

## Comparando Strings [#comparing-strings]

O Swift fornece tr√™s maneiras de comparar valores textuais: igualdade de string e caracteres, igualdade de prefixo e igualdade de sufixo.

### Igualdade de Strings e Caracteres [#string-and-character-equality]

A igualdade de string e caracteres √© verificada com o operador ‚Äúigual a‚Äù (`==`) e o operador ‚Äún√£o igual a‚Äù (`!=`), conforme descrito em [Operadores de Compara√ß√£o](/docs/language-guide/basics-operators#comparison-operators):

```swift lineNumbers
let quotation = "Somos muito parecidos, voc√™ e eu."
let sameQuotation = "Somos muito parecidos, voc√™ e eu."

if quotation == sameQuotation { // true
  print("Essas duas strings s√£o consideradas iguais")
}
```

Dois valores de String (ou dois valores de Character) s√£o considerados iguais se seus clusters de grafemas estendidos forem canonicamente equivalentes. Clusters de grafemas estendidos s√£o canonicamente equivalentes se tiverem o mesmo significado e apar√™ncia lingu√≠sticos, mesmo que sejam compostos de diferentes escalares Unicode nos bastidores.

Por exemplo, _LATIN SMALL LETTER E WITH ACUTE_ (`U+00E9`) √© canonicamente equivalente √† _LATIN SMALL LETTER E_ (`U+0065`) seguida de _COMBINING ACUTE ACCENT_ (`U+0301`). Ambos os clusters de grafema estendidos s√£o maneiras v√°lidas de representar o caractere `√©` e, portanto, s√£o considerados canonicamente equivalentes:

```swift lineNumbers
// "Voc√™ quer um caf√©?" Usando LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voc√™ quer um caf\u{e9}?"

// "Voc√™ quer um caf√©?" Usando LATIN SMALL LETTER E e COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voce quer um caf\u{65}\u{301}?"

if eAcuteQuestion == combinedEAcuteQuestion { // true
  print("Essas duas strings s√£o consideradas iguais")
}
```

Por outro lado, a _LATIN CAPITAL LETTER A_ (`U+0041`, ou "A"), como usada em ingl√™s, n√£o √© equivalente √† _CYRILLIC CAPITAL LETTER A_ (`U+0410`, ou "–ê"), como usada em russo. Os caracteres s√£o visualmente semelhantes, mas n√£o t√™m o mesmo significado lingu√≠stico:

```swift
let latinCapitalLetterA: Character = "\u{41}"

let cyrillicCapitalLetterA: Character = "\u{0410}"

if latinCapitalLetterA != cyrillicCapitalLetterA { //false
  print("Essas duas strings n√£o s√£o consideradas iguais")
}
```

<Callout title="Nota">
  As compara√ß√µes de strings e caracteres no Swift n√£o s√£o sens√≠veis √†
  localidade.
</Callout>

### Igualdade de prefixo e sufixo [#prefix-and-suffix-equality]

Para verificar se uma string tem um prefixo ou sufixo de string espec√≠fico, chame os m√©todos `hasPrefix(_:){:swift}` e `hasSuffix(_:){:swift}` da string, ambos os quais pegam um √∫nico argumento do tipo String e retornam um valor booleano.

Os exemplos abaixo consideram uma s√©rie de cordas que representam os locais das cenas dos dois primeiros atos de _Romeu e Julieta de Shakespeare_:

```swift lineNumbers
let romeoAndJuliet = [
  "Ato 1 Cena 1: Verona, Um lugar p√∫blico",
  "Ato 1 Cena 2: Mans√£o de Capuleto",
  "Ato 1 Cena 3: Um quarto na mans√£o de Capuleto",
  "Ato 1 Cena 4: Uma rua do lado de fora da mans√£o de Capuleto",
  "Ato 1 Cena 5: O Grande Sal√£o na mans√£o de Capuleto",
  "Ato 2 Cena 1: Fora da mans√£o de Capuleto",
  "Ato 2 Cena 2: Pomar de Capuleto",
  "Ato 2 Cena 3: Fora da cela do Frei Lawrence",
  "Ato 2 Cena 4: Uma rua em Verona",
  "Ato 2 Cena 5: Mans√£o de Capuleto",
  "Ato 2 Cena 6: A cela do Frei Lawrence"
]
```

Voc√™ pode usar o m√©todo `hasPrefix(_:){:swift}` com a matriz `romeoAndJuliet` para contar o n√∫mero de cenas no Ato 1 da pe√ßa:

```swift lineNumbers
var act1SceneCount = 0

for scene in romeoAndJuliet {
  if scene.hasPrefix("Act 1 ") {
    act1SceneCount += 1
  }
}

print("Existem \(act1SceneCount) cenas no Ato 1")
```

Da mesma forma, use o m√©todo `hasSuffix(_:){:swift}` para contar o n√∫mero de cenas que acontecem dentro ou ao redor da mans√£o de Capuleto e da cela do Frei Lawrence:

```swift lineNumbers
var mansionCount = 0
var cellCount = 0

for scene in romeoAndJuliet {
  if scene.hasSuffix("Mans√£o de Capuleto") {
    mansionCount += 1
  } else if scene.hasSuffix("A cela do Frei Lawrence") {
    cellCount =+ 1
  }
}

print("Cenas da mans√£o \(mansionCount); cenas da cela \(cellCount)")
```

<Callout title="Nota">
Os m√©todos `hasPrefix(_:){:swift}` e `hasSuffix(_:){swift}` realizam uma compara√ß√£o de equival√™ncia can√¥nica caractere por caractere entre os clusters de grafemas estendidos em cada string, conforme descrito em [String and Character Equality](#string-and-character-equality).
</Callout>

## Representa√ß√µes Unicode de Strings [#unicode-representation-of-strings]

Quando uma string Unicode √© gravada em um arquivo de texto ou em algum outro armazenamento, os escalares Unicode nessa string s√£o codificados em uma das v√°rias formas de codifica√ß√£o definidas pelo Unicode. Cada forma codifica a string em pequenos peda√ßos conhecidos como unidades de c√≥digo. Estes incluem o formul√°rio de codifica√ß√£o UTF-8 (que codifica uma string como unidades de c√≥digo de 8 bits), o formul√°rio de codifica√ß√£o UTF-16 (que codifica uma string como unidades de c√≥digo de 16 bits) e o formul√°rio de codifica√ß√£o UTF-32 (que codifica uma string como unidades de c√≥digo de 32 bits).

O Swift fornece v√°rias maneiras diferentes de acessar representa√ß√µes Unicode de strings. Voc√™ pode iterar sobre a string com uma instru√ß√£o for-in, para acessar seus valores de caracteres individuais como clusters de grafemas estendidos Unicode. Este processo √© descrito em [Trabalhando com Caracteres](#working-with-characters).

Alternativamente, acesse um valor de String em uma das tr√™s outras representa√ß√µes compat√≠veis com Unicode:

- Uma cole√ß√£o de unidades de c√≥digo UTF-8 (acessadas com a propriedade utf8 da string)
- Uma cole√ß√£o de unidades de c√≥digo UTF-16 (acessadas com a propriedade utf16 da string)
- Uma cole√ß√£o de valores escalares Unicode de 21 bits, equivalentes ao formul√°rio de codifica√ß√£o UTF-32 da string (acessado com a propriedade unicodeScalars da string)

Cada exemplo abaixo mostra uma representa√ß√£o diferente da seguinte string, que √© composta pelos caracteres D, o, g, !! (_DOUBLE EXCLAMATION MARK_, ou Unicode escalar `U+203C`), e o caractere üê∂ (_DOG FACE_, ou Unicode escalar `U+1F436`):

```swift
let dogString = "Dog!!üê∂"
```

### Representa√ß√£o UTF-8 [#utf-8-representation]

Voc√™ pode acessar uma representa√ß√£o UTF-8 de uma String iterando sobre sua propriedade utf8. Esta propriedade √© do tipo `String.UTF8View`, que √© uma cole√ß√£o de valores de 8 bits (`UInt8`) n√£o assinados, um para cada byte na representa√ß√£o UTF-8 da string:

<UTF8RepresentationExemple />

```swift lineNumbers
for codeUnit in dogString.utf8 {
  print("\(codeUnit) ", terminator: "")
}
// 68 111 103 226 128 188 240 159 144 182
```

No exemplo acima, os tr√™s primeiros valores de unidade de c√≥digo decimal (68, 111, 103) representam os caracteres D, o e g, cuja representa√ß√£o UTF-8 √© a mesma que sua representa√ß√£o ASCII. Os pr√≥ximos tr√™s valores de unidade de c√≥digo decimal (226, 128, 188) s√£o uma representa√ß√£o UTF-8 de tr√™s bytes do caractere _DOUBLE EXCLAMATION MARK_. Os √∫ltimos quatro valores `codeUnit` (240, 159, 144, 182) s√£o uma representa√ß√£o UTF-8 de quatro bytes do caractere _DOG FACE_.

### Representa√ß√£o UTF-16 [#utf-16-representation]

Voc√™ pode acessar uma representa√ß√£o UTF-16 de uma String iterando sobre sua propriedade utf16. Esta propriedade √© do tipo `String.UTF16View`, que √© uma cole√ß√£o de valores n√£o assinados de 16 bits (`UInt16`), um para cada unidade de c√≥digo de 16 bits na representa√ß√£o UTF-16 da string:

<UTF16RepresentationExemple />

```swift lineNumbers
for codeUnit in dogString.utf16 {
  print("\(codeUnit) ", terminator: "")
}
// 68 111 103 8252 55357 56374
```

Novamente, os tr√™s primeiros valores de `codeUnit` (68, 111, 103) representam os caracteres D, o e g, cujas unidades de c√≥digo UTF-16 t√™m os mesmos valores da representa√ß√£o UTF-8 da string (porque esses escalares Unicode representam caracteres ASCII).

O quarto valor `codeUnit` (8252) √© um equivalente decimal do valor hexadecimal 203C, que representa o escalar Unicode `U+203C` para o caractere _DOUBLE EXCLAMATION MARK_. Este caractere pode ser representado como uma √∫nica unidade de c√≥digo em UTF-16.

Os quinto e sextos valores `codeUnit` (55357 e 56374) s√£o uma representa√ß√£o de par substituto UTF-16 do caractere _DOG FACE_. Esses valores s√£o um valor substituto alto de `U+D83D` (valor decimal 55357) e um valor substituto baixo de `U+DC36` (valor decimal 56374).

### Representa√ß√£o Escalar Unicode [#unicode-scalar-representation]

Voc√™ pode acessar uma representa√ß√£o escalar Unicode de um valor String iterando sobre sua propriedade `unicodeScalars`. Esta propriedade √© do tipo `UnicodeScalarView`, que √© uma cole√ß√£o de valores do tipo `UnicodeScalar`.

Cada `UnicodeScalar` tem uma propriedade de valor que retorna o valor de 21 bits do escalar, representado dentro de um valor `UInt32`:

<UnicodeScalarRepresentationExemple />

```swift lineNumbers
for scalar in dogString.unicodeScalars {
  print("\(scalar.value) ", terminator: "")
}
// 68 111 103 8252 128054
```

As propriedades de valor para os tr√™s primeiros valores `UnicodeScalar` (68, 111, 103) mais uma vez representam os caracteres D, o e g.

O quarto valor codeUnit (8252) √© novamente um equivalente decimal do valor hexadecimal 203C, que representa o escalar Unicode `U+203C` para o caractere _DOUBLE EXCLAMATION MARK_.

A propriedade de valor do quinto e √∫ltimo `UnicodeScalar`, 128054, √© um equivalente decimal do valor hexadecimal 1F436, que representa o escalar Unicode `U+1F436` para o caractere _DOG FACE_.

Como alternativa √† consulta de suas propriedades de valor, cada valor `UnicodeScalar` tamb√©m pode ser usado para construir um novo valor de String, como com interpola√ß√£o de string:

```swift lineNumbers
// [!code focus:3]
for scalar in dogString.unicodeScalars {
  print("\(scalar) ")
}
// D
// o
// g
// !!
// üê∂
```
