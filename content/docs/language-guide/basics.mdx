---
title: O B√°sico
description: O tutorial de boas-vindas do c√≥digo, onde voc√™ aprende a falar "ol√° mundo" e dominar o b√°sico como um(a) Jedi iniciante! üåüüññ
---

Swift √© uma nova linguagem de programa√ß√£o para o desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. No entanto, muitas partes do Swift ser√£o familiares a partir de sua experi√™ncia de desenvolvimento em C e Objective-C.

Swift fornece suas pr√≥prias vers√µes de todos os tipos fundamentais de C e Objective-C, incluindo `Int` para inteiros, `Double` e `Float` para valores de ponto flutuante, `Bool` para valores booleanos e `String` para dados textuais. O Swift tamb√©m fornece vers√µes poderosas dos tr√™s tipos de cole√ß√£o prim√°rios, `Array`, `Set` e `Dictionary`, conforme descrito em [Tipos de Cole√ß√£o](/docs/language-guide/collection-types).

Como C, o Swift usa vari√°veis para armazenar e se referir a valores por um nome de identifica√ß√£o. O Swift tamb√©m faz uso extensivo de vari√°veis cujos valores n√£o podem ser alterados. Estas s√£o conhecidas como constantes e s√£o muito mais poderosas do que as constantes em C. As constantes s√£o usadas em todo o Swift para tornar o c√≥digo mais seguro e claro na inten√ß√£o quando voc√™ trabalha com valores que n√£o precisam mudar.

Al√©m dos tipos familiares, o Swift introduz tipos avan√ßados n√£o encontrados no Objective-C, como tuplas. As tuplas permitem que voc√™ crie e passe agrupamentos de valores. Voc√™ pode usar uma tupla para retornar v√°rios valores de uma fun√ß√£o como um √∫nico valor composto.

O Swift tamb√©m introduz tipos opcionais, que lidam com a aus√™ncia de um valor. Opcionais dizem ‚Äúh√° um valor, e √© igual a x‚Äù ou ‚Äún√£o h√° valor algum‚Äù. Usar opcionais √© semelhante ao uso de nil com ponteiros no Objective-C, mas eles funcionam para qualquer tipo, n√£o apenas para classes. Os opcionais n√£o s√£o apenas mais seguros e expressivos do que os ponteiros nulos no Objective-C, como tamb√©m est√£o no centro de muitos dos recursos mais poderosos do Swift.

Swift √© uma linguagem de tipo seguro, o que significa que a linguagem ajuda voc√™ a ser claro sobre os tipos de valores com os quais seu c√≥digo pode trabalhar. Se parte do seu c√≥digo requer uma String, a seguran√ßa do tipo impede que voc√™ passe um Int por engano. Da mesma forma, a seguran√ßa do tipo impede que voc√™ passe acidentalmente uma String opcional para um peda√ßo de c√≥digo que requer um String n√£o opcional. Tipos seguros ajuda voc√™ a detectar e corrigir erros o mais cedo poss√≠vel no processo de desenvolvimento.

## Constantes e Vari√°veis

Constantes e vari√°veis associam um nome (como `maximumNumberOfLoginAttempts` ou `welcomeMessage`) a um valor de um tipo espec√≠fico (como o n√∫mero 10 ou a string "Hello"). O valor de uma constante n√£o pode ser alterado uma vez definido, enquanto uma vari√°vel pode ser definida para um valor diferente no futuro.

### Declarando Constantes e Vari√°veis

Constantes e vari√°veis devem ser declaradas antes de serem usadas. Voc√™ declara constantes com a palavra-chave `let` e vari√°veis com a palavra-chave `var`. Aqui est√° um exemplo de como constantes e vari√°veis podem ser usadas para rastrear o n√∫mero de tentativas de login que um usu√°rio fez:

```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```

Este c√≥digo pode ser lido como:

‚ÄúDeclare uma nova constante chamada `maximumNumberOfLoginAttempts` e d√™ a ela um valor de 10. Em seguida, declare uma nova vari√°vel chamada `currentLoginAttempt` e d√™ a ela um valor inicial de 0.‚Äù

Neste exemplo, o n√∫mero m√°ximo de tentativas de login permitidas √© declarado como uma constante, porque o valor m√°ximo nunca muda. O contador de tentativa de login atual √© declarado como uma vari√°vel, porque esse valor deve ser incrementado ap√≥s cada tentativa de login com falha.

Voc√™ pode declarar v√°rias constantes ou v√°rias vari√°veis em uma √∫nica linha, separadas por v√≠rgulas:

```swift
var x = 0.0, y = 0.0, z = 0.0
```

<Callout title="Nota">
  Se um valor armazenado em seu c√≥digo n√£o mudar, sempre declare-o como uma
  constante com a palavra-chave `let`. Use vari√°veis apenas para armazenar
  valores que precisam ser capazes de mudar.
</Callout>

### Anota√ß√µes de tipo

Voc√™ pode fornecer uma _anota√ß√£o de tipo_ ao declarar uma constante ou vari√°vel, para ser claro sobre o tipo de valores que a constante ou vari√°vel pode armazenar. Escreva uma anota√ß√£o de tipo colocando dois pontos ap√≥s o nome da constante ou vari√°vel, seguido por um espa√ßo, seguido pelo nome do tipo a ser usado.

Este exemplo fornece uma anota√ß√£o de tipo para uma vari√°vel chamada welcomeMessage, para indicar que a vari√°vel pode armazenar valores de String:

```swift
var welcomeMessage: String
```

Os dois pontos na declara√ß√£o significa ‚Äú...do tipo...‚Äù, ent√£o o c√≥digo acima pode ser lido como:

‚ÄúDeclare uma vari√°vel chamada `welcomeMessage` que √© do tipo String.‚Äù

A frase ‚Äúdo tipo String‚Äù significa ‚Äúpode armazenar qualquer valor String‚Äù. Pense nisso como significando ‚Äúo tipo de coisa‚Äù (ou ‚Äúo tipo de coisa‚Äù) que pode ser armazenada.

A vari√°vel `welcomeMessage` agora pode ser definida para qualquer valor de string sem erro:

```swift
welcomeMessage = "Ol√°"
```

Voc√™ pode definir v√°rias vari√°veis relacionadas do mesmo tipo em uma √∫nica linha, separadas por v√≠rgulas, com uma anota√ß√£o de tipo √∫nico ap√≥s o nome da vari√°vel final:

```swift
var red, green, blue: Double
```

<Callout title="Nota">
  √â raro que voc√™ precise escrever anota√ß√µes de tipo na pr√°tica. Se voc√™
  fornecer um valor inicial para uma constante ou vari√°vel no ponto em que ela √©
  definida, o Swift quase sempre pode inferir o tipo a ser usado para essa
  constante ou vari√°vel, conforme descrito em [Seguran√ßa de Tipo e Infer√™ncia de
  Tipo](/docs/language-guide/basics#type-safety-and-type-inference). No exemplo
  `welcomeMessage` acima, nenhum valor inicial √© fornecido e, portanto, o tipo
  da vari√°vel `welcomeMessage` √© especificado com uma anota√ß√£o de tipo em vez de
  ser inferido a partir de um valor inicial.
</Callout>

### Nomeando Constantes e Vari√°veis

Nomes constantes e vari√°veis podem conter quase qualquer caractere, incluindo caracteres Unicode:

```swift
let œÄ = 3.14159
let ‰Ω†Â•Ω = "‰Ω†Â•Ω‰∏ñÁïå"
let üê∂üêÆ = "dogcow"
```

Nomes constantes e vari√°veis n√£o podem conter caracteres de espa√ßo em branco, s√≠mbolos matem√°ticos, setas, valores escalares Unicode de uso privado ou caracteres de desenho de linha e caixa. Nem podem come√ßar com um n√∫mero, embora os n√∫meros possam ser inclu√≠dos em outro lugar dentro do nome.

Depois de declarar uma constante ou vari√°vel de um determinado tipo, voc√™ n√£o pode declar√°-la novamente com o mesmo nome ou alter√°-la para armazenar valores de um tipo diferente. Nem voc√™ pode transformar uma constante em uma vari√°vel ou uma vari√°vel em uma constante.

<Callout title="Note">

Se voc√™ precisar dar a uma constante ou vari√°vel o mesmo nome de uma palavra-chave Swift reservada, envolva a palavra-chave com crase (`) ao us√°-la como nome. No entanto, evite usar palavras-chave como nomes, a menos que voc√™ n√£o tenha absolutamente nenhuma escolha.

</Callout>

Voc√™ pode alterar o valor de uma vari√°vel existente para outro valor de um tipo compat√≠vel. Neste exemplo, o valor de `friendlyWelcome` √© alterado de "Ol√°!" Para "Bonjour!":

```swift
var friendlyWelcome = "Ol√°!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome agora √© "Bonjour!"
```

Ao contr√°rio de uma vari√°vel, o valor de uma constante n√£o pode ser alterado depois de definido. Tentar fazer isso √© relatado como um erro quando seu c√≥digo √© compilado:

```swift
let languageName = "Swift"
languageName = "Swift++"
// Este √© um erro de tempo de compila√ß√£o: languageName cannot be changed.
```

### Impress√£o de Constantes e Vari√°veis

Voc√™ pode imprimir o valor atual de uma constante ou vari√°vel com a fun√ß√£o `print(_:separator:terminator:){:swift}`:

```swift
print(friendlyWelcome) // Bonjour!
```

A fun√ß√£o `print(_:separator:terminator:){:swift}` √© uma fun√ß√£o global que imprime um ou mais valores para uma sa√≠da apropriada. No Xcode, por exemplo, a fun√ß√£o `print(_:separator:terminator:){:swift}` imprime sua sa√≠da no painel ‚Äúconsole‚Äù do Xcode. O par√¢metro separador e terminador t√™m valores padr√£o, ent√£o voc√™ pode omiti-los ao chamar esta fun√ß√£o. Por padr√£o, a fun√ß√£o termina a linha que imprime adicionando uma quebra de linha. Para imprimir um valor sem uma quebra de linha depois dele, passe uma string vazia como o terminador‚Äîpor exemplo, `print(someValue, terminator: ""){:swift}`. Para obter informa√ß√µes sobre par√¢metros com valores padr√£o, consulte [Valores de Par√¢metros Padr√£o]().

O Swift usa a _interpola√ß√£o_ de strings para incluir o nome de uma constante ou vari√°vel como um espa√ßo reservado em uma string mais longa e para solicitar ao Swift que a substitua pelo valor atual dessa constante ou vari√°vel. Enrole o nome entre par√™nteses e escape-o com uma barra invertida antes do par√™ntese de abertura:

```swift
print("O valor atual de friendlyWelcome √© \(friendlyWelcome)") // O valor atual de friendlyWelcome √© Bonjour!
```

<Callout title="Nota">
  Todas as op√ß√µes que voc√™ pode usar com a interpola√ß√£o de strings s√£o descritas
  em [Interpola√ß√£o de
  String](/docs/language-guide/strings-and-characters#string-interpolation).
</Callout>

## Coment√°rios

Use coment√°rios para incluir texto n√£o execut√°vel em seu c√≥digo, como uma nota ou lembrete para si mesmo. Os coment√°rios s√£o ignorados pelo compilador Swift quando seu c√≥digo √© compilado.

Coment√°rios em Swift s√£o muito semelhantes aos coment√°rios em C. Coment√°rios de linha √∫nica come√ßam com duas barras para frente (`//`):

```swift
// Isso √© um coment√°rio
```

Os coment√°rios de v√°rias linhas come√ßam com uma barra para frente seguida por um asterisco (`/*`) e terminam com um asterisco seguido por uma barra para frente (`*/`):

```swift
/* Isso √© outro coment√°rio
por√©m escrito em m√∫ltiplas linhas */
```

Ao contr√°rio dos coment√°rios de v√°rias linhas em C, os coment√°rios de v√°rias linhas no Swift podem ser aninhados dentro de outros coment√°rios de v√°rias linhas. Voc√™ escreve coment√°rios aninhados iniciando um bloco de coment√°rios de v√°rias linhas e, em seguida, iniciando um segundo coment√°rio de v√°rias linhas dentro do primeiro bloco. O segundo bloco √© ent√£o fechado, seguido pelo primeiro bloco:

```swift
/* Esse √© o come√ßo do coment√°rio em varias linhas
/* Esse e a segunda parte, aninhada do coment√°rio de varias linhas*/
Esse √© o fim do coment√°rio de varias linhas */
```

Os coment√°rios aninhados de v√°rias linhas permitem que voc√™ comente grandes blocos de c√≥digo de forma r√°pida e f√°cil, mesmo que o c√≥digo j√° contenha coment√°rios de v√°rias linhas.

## Ponto e v√≠rgula

Ao contr√°rio de muitos outros idiomas, o Swift n√£o exige que voc√™ escreva um ponto e v√≠rgula (`;`) ap√≥s cada instru√ß√£o em seu c√≥digo, embora voc√™ possa faz√™-lo se desejar. No entanto, pontos e v√≠rgula s√£o necess√°rios se voc√™ quiser escrever v√°rias instru√ß√µes separadas em uma √∫nica linha:

```swift
let cat = "üê±"; print(cat) // üê±
```

## Inteiros

Os inteiros s√£o n√∫meros sem componente fracion√°rio, como 42 e -23. Os inteiros s√£o assinados (positivo, zero ou negativo) ou n√£o assinados (positivo ou zero).

O Swift fornece inteiros assinados e n√£o assinados nas formas de 8, 16, 32 e 64 bits. Esses inteiros seguem uma conven√ß√£o de nomenclatura semelhante a C, em que um inteiro sem sinal de 8 bits √© do tipo `UInt8` e um inteiro com sinal de 32 bits √© do tipo `Int32`. Como todos os tipos no Swift, esses tipos inteiros t√™m nomes em mai√∫sculas.

### Limites Inteiros

Voc√™ pode acessar os valores m√≠nimo e m√°ximo de cada tipo inteiro com suas propriedades m√≠nima e m√°xima:

```swift
let minValue = UInt8.min // minValue √© igual a 0, e √© do tipo UInt8
let maxValue = UInt8.max // maxValue √© igual a 255, e √© do tipo UInt8
```

Os valores dessas propriedades s√£o do tipo de n√∫mero de tamanho apropriado (como `UInt8` no exemplo acima) e, portanto, podem ser usados em express√µes ao lado de outros valores do mesmo tipo.

### `Int`

Na maioria dos casos, voc√™ n√£o precisa escolher um tamanho espec√≠fico de inteiro para usar em seu c√≥digo. O Swift fornece um tipo inteiro adicional, `Int`, que tem o mesmo tamanho do tamanho da palavra nativa da plataforma atual:

- Em uma plataforma de 32 bits, o `Int` tem o mesmo tamanho do `Int32`.
- Em uma plataforma de 64 bits, o `Int` √© do mesmo tamanho que o `Int64`.

A menos que voc√™ precise trabalhar com um tamanho espec√≠fico de inteiro, sempre use `Int` para valores inteiros em seu c√≥digo. Isso ajuda na consist√™ncia e interoperabilidade do c√≥digo. Mesmo em plataformas de 32 bits, o `Int` pode armazenar qualquer valor entre -2.147.483.648 e 2.147.483.647, e √© grande o suficiente para muitos intervalos inteiros.

### `UInt`

O Swift tamb√©m fornece um tipo inteiro sem sinal, `UInt`, que tem o mesmo tamanho do tamanho da palavra nativa da plataforma atual:

- Em uma plataforma de 32 bits, `UInt` tem o mesmo tamanho que `UInt32`.
- Em uma plataforma de 64 bits, `UInt` tem o mesmo tamanho que `UInt64`.

<Callout title="Nota">
  Use o `UInt` somente quando precisar especificamente de um tipo inteiro n√£o
  assinado com o mesmo tamanho do tamanho da palavra nativa da plataforma. Se
  este n√£o for o caso, `Int` √© o preferido, mesmo quando os valores a serem
  armazenados s√£o conhecidos por n√£o serem negativos. Um uso consistente de Int
  para valores inteiros auxilia na interoperabilidade do c√≥digo, evita a
  necessidade de converter entre diferentes tipos de n√∫meros e corresponde √†
  infer√™ncia do tipo inteiro, conforme descrito em [Seguran√ßa de Tipo e
  Infer√™ncia de
  Tipo](/docs/language-guide/basics#type-safety-and-type-inference).
</Callout>

## N√∫meros de ponto flutuante

_N√∫meros de ponto flutuante_ s√£o n√∫meros com um componente fracion√°rio, como 3.14159, 0,1 e -273.15.

Os tipos de ponto flutuante podem representar uma gama muito mais ampla de valores do que os tipos inteiros e podem armazenar n√∫meros que s√£o muito maiores ou menores do que podem ser armazenados em um `Int`. O Swift fornece dois tipos de n√∫meros de ponto flutuante assinados:

- `Double` representa um n√∫mero de ponto flutuante de 64 bits.
- `Float` representa um n√∫mero de ponto flutuante de 32 bits.

<Callout title="Nota">
  `Double` tem uma precis√£o de pelo menos 15 d√≠gitos decimais, enquanto a
  precis√£o de `Float` pode ser t√£o pequena quanto 6 d√≠gitos decimais. O tipo de
  ponto flutuante apropriado a ser usado depende da natureza e do intervalo de
  valores com os quais voc√™ precisa trabalhar em seu c√≥digo. Em situa√ß√µes em que
  qualquer um dos tipos seria apropriado, `Double` √© o preferido.
</Callout>

## Seguran√ßa de tipo e infer√™ncia de tipo [#type-safety-and-type-inference]

Swift √© uma linguagem de _tipo seguro_. Uma linguagem segura incentiva voc√™ a ser claro sobre os tipos de valores com os quais seu c√≥digo pode funcionar. Se parte do seu c√≥digo requer uma `String`, voc√™ n√£o pode passar um `Int` por engano.

Como o Swift √© seguro de tipo, ele realiza _verifica√ß√µes de tipo_ ao compilar seu c√≥digo e sinaliza quaisquer tipos incompat√≠veis como erros. Isso permite que voc√™ detecte e corrija erros o mais cedo poss√≠vel no processo de desenvolvimento.

A verifica√ß√£o de tipo ajuda voc√™ a evitar erros ao trabalhar com diferentes tipos de valores. No entanto, isso n√£o significa que voc√™ tenha que especificar o tipo de cada constante e vari√°vel que declarar. Se voc√™ n√£o especificar o tipo de valor que precisa, o Swift usa infer√™ncia de tipo para resolver o tipo apropriado. A infer√™ncia de tipo permite que um compilador deduza o tipo de uma express√£o espec√≠fica automaticamente quando compila seu c√≥digo, simplesmente examinando os valores que voc√™ fornece.

Por causa da infer√™ncia de tipo, o Swift requer muito menos declara√ß√µes de tipo do que linguagens como C ou Objective-C. Constantes e vari√°veis ainda s√£o explicitamente digitadas, mas grande parte do trabalho de especificar seu tipo √© feito para voc√™.

A infer√™ncia de tipo √© particularmente √∫til quando voc√™ declara uma constante ou vari√°vel com um valor inicial. Isso geralmente √© feito atribuindo um valor literal (ou _literal_) √† constante ou vari√°vel no ponto em que voc√™ a declara. (Um valor literal √© um valor que aparece diretamente no seu c√≥digo-fonte, como 42 e 3.14159 nos exemplos abaixo.)

Por exemplo, se voc√™ atribuir um valor literal de 42 a uma nova constante sem dizer que tipo √©, o Swift infere que voc√™ deseja que a constante seja um Int, porque voc√™ a inicializou com um n√∫mero que se parece com um inteiro:

```swift
let meaningOfLife = 42 // meaningOfLife √© inferido para ser do tipo Int
```

Da mesma forma, se voc√™ n√£o especificar um tipo para um literal de ponto flutuante, o Swift infere que voc√™ deseja criar um `Double`:

```swift
let PI = 3.14159 // PI √© inferido para ser do tipo Double
```

Swift sempre escolhe `Double` (em vez de `Float`) ao inferir o tipo de n√∫meros de ponto flutuante.

Se voc√™ combinar literais inteiros e de ponto flutuante em uma express√£o, um tipo de `Double` ser√° inferido do contexto:

```swift
let anotherPI = 3 + 0.14159 // anotherPI is
```

O valor literal de 3 n√£o tem um tipo expl√≠cito por si s√≥ e, portanto, um tipo de sa√≠da apropriado de Double √© inferido a partir da presen√ßa de um literal de ponto flutuante como parte da adi√ß√£o.

## Literais Num√©ricos

Literais inteiros podem ser escritos como:

- Um n√∫mero _decimal_, sem prefixo
- Um n√∫mero `bin√°rio`, com um prefixo `0b`
- Um n√∫mero `octal`, com um prefixo `0o`
- Um n√∫mero `hexadecimal`, com um prefixo `0x`

Todos esses literais inteiros t√™m um valor decimal de 17:

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 em anota√ß√£o binaria
let octalInteger = 0o21           // 17 em anota√ß√£o octal
let hexadecimalInteger = 0x11     // 17 em anota√ß√£o hexadecimal
```

Os literais de ponto flutuante podem ser decimais (sem prefixo) ou hexadecimais (com um prefixo `0x`). Eles devem sempre ter um n√∫mero (ou n√∫mero hexadecimal) em ambos os lados do ponto decimal. Os flutuadores decimais tamb√©m podem ter um expoente opcional, indicado por um e mai√∫sculo ou min√∫sculo; os flutuadores hexadecimais devem ter um expoente, indicado por um `p` mai√∫sculo ou min√∫sculo.

Para n√∫meros decimais com um expoente de `exp`, o n√∫mero base √© multiplicado por $$10^{exp}$$`:

1,25e2 significa 1,25 x $$10^2$$, ou 125,0.

1,25e-2 significa 1,25 x $$10^{-2}$$, ou 0,0125.

Para n√∫meros hexadecimais com um expoente de exp, o n√∫mero base √© multiplicado por $$2^{exp}$$:

0xFp2 significa 15 x $$2^2$$, ou 60,0.

0xFp-2 significa 15 x $$2^{-2}$$, ou 3,75.

Todos esses literais de ponto flutuante t√™m um valor decimal de 12,1875:

```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

Os literais num√©ricos podem conter formata√ß√£o extra para torn√°-los mais f√°ceis de ler. Tanto os inteiros quanto os flutuadores podem ser preenchidos com zeros extras e podem conter sublinhados para ajudar na legibilidade. Nenhum tipo de formata√ß√£o afeta o valor subjacente do literal:

```swift
let paddedDouble = 00123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

## Convers√£o de tipo num√©rico

Use o tipo Int para todas as constantes e vari√°veis inteiras de uso geral em seu c√≥digo, mesmo que sejam conhecidas por n√£o serem negativas. Usar o tipo inteiro padr√£o em situa√ß√µes cotidianas significa que constantes e vari√°veis inteiras s√£o imediatamente interoper√°veis em seu c√≥digo e corresponder√£o ao tipo inferido para valores literais inteiros.

Use outros tipos inteiros apenas quando forem especificamente necess√°rios para a tarefa em quest√£o, por causa de dados explicitamente dimensionados de uma fonte externa ou para desempenho, uso de mem√≥ria ou outras otimiza√ß√µes necess√°rias. O uso de tipos de tamanho expl√≠cito nessas situa√ß√µes ajuda a capturar quaisquer excessos acidentais de valor e documenta implicitamente a natureza dos dados que est√£o sendo usados.

### Convers√£o de Inteiro

O intervalo de n√∫meros que podem ser armazenados em uma constante ou vari√°vel inteira √© diferente para cada tipo num√©rico. Uma constante ou vari√°vel `Int8` pode armazenar n√∫meros entre -128 e 127, enquanto uma constante ou vari√°vel `UInt8` pode armazenar n√∫meros entre 0 e 255. Um n√∫mero que n√£o se encaixa em uma constante ou vari√°vel de um tipo inteiro de tamanho √© relatado como um erro quando seu c√≥digo √© compilado:

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 n√£o pode armazenar n√∫meros negativos e, portanto, isso relatar√° um erro

let tooBig: Int8 = Int8.max + 1
// Int8 n√£o pode armazenar um n√∫mero maior do que seu valor m√°ximo, assim isso tamb√©m relatar√° um erro
```

Como cada tipo num√©rico pode armazenar um intervalo diferente de valores, voc√™ deve optar pela convers√£o de tipo num√©rico caso a caso. Essa abordagem `opt-in` evita erros de convers√£o ocultos e ajuda a tornar expl√≠citas as inten√ß√µes de convers√£o de tipo em seu c√≥digo.

Para converter um tipo de n√∫mero espec√≠fico para outro, voc√™ inicializa um novo n√∫mero do tipo desejado com o valor existente. No exemplo abaixo, a constante `twoThousand` √© do tipo `UInt16`, enquanto a constante um √© do tipo `UInt8`. Eles n√£o podem ser adicionados diretamente, porque n√£o s√£o do mesmo tipo. Em vez disso, este exemplo chama `UInt16(one){:swift}` para criar um novo `UInt16` inicializado com o valor de um e usa este valor no lugar do original:

```swift
let twoThousand: UInt16 = 2_000
let one = UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```

Como ambos os lados da adi√ß√£o agora s√£o do tipo `UInt16`, a adi√ß√£o √© permitida. A constante de sa√≠da (twoThousandAndOne) √© inferida como sendo do tipo `UInt16`, porque √© a soma de dois valores `UInt16`.

`SomeType(ofInitialValue){:swift}` √© a maneira padr√£o de chamar o inicializador de um tipo Swift e passar um valor inicial. Nos bastidores, o `UInt16` tem um inicializador que aceita um valor UInt8 e, portanto, esse inicializador √© usado para criar um novo `UInt16` a partir de um UInt8 existente. Voc√™ n√£o pode passar nenhum tipo aqui, no entanto, tem que ser um tipo para o qual o `UInt16` fornece um inicializador. A extens√£o dos tipos existentes para fornecer inicializadores que aceitam novos tipos (incluindo suas pr√≥prias defini√ß√µes de tipo) √© abordado em [Extens√µes]().

### Convers√£o de Inteiro e Ponto Flutuante

As convers√µes entre tipos num√©ricos inteiros e de ponto flutuante devem ser explicitadas:

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let PI = Double(three) + pointOneFourOneFiveNine
// PI igual a 3.14159, e √© inferido para ser do tipo Double
```

Aqui, o valor da constante tr√™s √© usado para criar um novo valor do tipo `Double`, de modo que ambos os lados da adi√ß√£o sejam do mesmo tipo. Sem essa convers√£o em vigor, a adi√ß√£o n√£o seria permitida.

A convers√£o de ponto flutuante para inteiro tamb√©m deve ser explicitada. Um tipo inteiro pode ser inicializado com um valor Double ou Float:

```swift
let integerPI = Int(PI)
// integerPi igual a 3, e √© inferido para ser do tipo Int
```

Os valores de ponto flutuante s√£o sempre truncados quando usados para inicializar um novo valor inteiro dessa maneira. Isso significa que 4,75 se torna 4 e -3,9 se torna -3.

<Callout title="Nota">
  As regras para combinar constantes num√©ricas e vari√°veis s√£o diferentes das
  regras para literais num√©ricos. O valor literal 3 pode ser adicionado
  diretamente ao valor literal 0,14159, porque os literais num√©ricos n√£o t√™m um
  tipo expl√≠cito em si mesmos. Seu tipo √© inferido apenas no momento em que eles
  s√£o avaliados pelo compilador.
</Callout>

## Type Aliases

_Aliases de tipo_ definem um nome alternativo para um tipo existente. Voc√™ define aliases de tipo com a palavra-chave `typealias`.

Aliases de tipo s√£o √∫teis quando voc√™ deseja se referir a um tipo existente por um nome que seja contextualmente mais apropriado, como ao trabalhar com dados de um tamanho espec√≠fico de uma fonte externa:

```swift
typealias AudioSample = UInt16
```

Depois de definir um alias de tipo, voc√™ pode usar o alias em qualquer lugar que possa usar o nome original:

```swift
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound agora √© 0
```

Aqui, o `AudioSample` √© definido como um alias para `UInt16`. Por ser um alias, a chamada para `AudioSample.min{:swift}` na verdade chama `UInt16.min{:swift}`, que fornece um valor inicial de 0 para a vari√°vel maxAmplitudeFound.

## Booleans

Swift tem um tipo booleano b√°sico, chamado `Bool`. Os valores booleanos s√£o referidos como l√≥gicos, porque s√≥ podem ser verdadeiros ou falsos. Swift fornece dois valores constantes booleanos, `true` e `false`:

```swift
let orangeAreOrange = true
let turnupsAreDelicious = false
```

Os tipos de `orangesAreOrange` e `turnipsAreDelicious` foram inferidos como `Bool` a partir do fato de terem sido inicializados com valores literais booleanos. Assim como no `Int` e no `Double` acima, voc√™ n√£o precisa declarar constantes ou vari√°veis como `Bool` se as definir como `true` ou `false` assim que as criar. A infer√™ncia de tipo ajuda a tornar o c√≥digo Swift mais conciso e leg√≠vel quando ele inicializa constantes ou vari√°veis com outros valores cujo tipo j√° √© conhecido.

Valores booleanos s√£o particularmente √∫teis quando voc√™ trabalha com instru√ß√µes condicionais, como a instru√ß√£o `if`:

```swift
if turnipsAreDelicious {
  print("Hmm, nabos saborosos!")
} else {
  print("Eca, nabos s√£o horr√≠veis.")
}

// Retorna: Eca, nabos s√£o horr√≠veis.
```

Instru√ß√µes condicionais, como a instru√ß√£o if, s√£o abordadas com mais detalhes no [Fluxo de Controle](../control-flow/index.mdx).

A seguran√ßa do tipo Swift impede que valores n√£o booleanos sejam substitu√≠dos por `Bool`. O exemplo a seguir relata um erro de tempo de compila√ß√£o:

```swift
let i = 1
if i {
  // Este exemplo n√£o ser√° compilado e relatar√° um erro
}
```

No entanto, o exemplo alternativo abaixo √© v√°lido:

```swift
let i = 1
if i == 1 {
  // Este exemplo ser√° compilado com sucesso
}
```

O resultado da compara√ß√£o `i == 1` √© do tipo `Bool` e, portanto, este segundo exemplo passa na verifica√ß√£o de tipo. Compara√ß√µes como `i == 1` s√£o discutidas em [Operadores B√°sicos](/docs/language-guide/basic-operators).

Assim como outros exemplos de seguran√ßa de tipo no Swift, essa abordagem evita erros acidentais e garante que a inten√ß√£o de uma se√ß√£o espec√≠fica de c√≥digo seja sempre clara.

## Tuplas

As _tuplas_ agrupam v√°rios valores em um √∫nico valor composto. Os valores dentro de uma tupla podem ser de qualquer tipo e n√£o precisam ser do mesmo tipo entre si.

Neste exemplo, `(404, "Not Found"){:swift}` √© uma tupla que descreve um c√≥digo de status HTTP. Um c√≥digo de status HTTP √© um valor especial retornado por um servidor da web sempre que voc√™ solicita uma p√°gina da web. Um c√≥digo de status de 404 N√£o Encontrado √© retornado se voc√™ solicitar uma p√°gina da web que n√£o existe.

```swift
let http404Error = (404, "Not Found")
// http404Error √© do tipo (Int, String), e √© igual a (404, "Not Found")
```

A tupla `(404, "N√£o Encontrado"){:swift}` agrupa um `Int` e uma `String` para dar ao c√≥digo de status HTTP dois valores separados: um n√∫mero e uma descri√ß√£o leg√≠vel por humanos. Pode ser descrito como ‚Äúuma tupla do tipo `(Int, String){:swift}`‚Äù.

Voc√™ pode criar tuplas a partir de qualquer permuta√ß√£o de tipos, e elas podem conter quantos tipos diferentes voc√™ quiser. N√£o h√° nada que o impe√ßa de ter uma tupla de tipo `(Int, Int, Int){:swift}`, ou `(String, Bool){:swift}`, ou de fato qualquer outra permuta√ß√£o que voc√™ precise.

Voc√™ pode decompor o conte√∫do de uma tupla em constantes ou vari√°veis separadas, que voc√™ acessa normalmente:

```swift
let (statusCode, statusMessage) = http404Error
print("O c√≥digo de status √© \(statusCode)") // O c√≥digo de status √© 404
print("A mensagem de status √© \(statusMessage)") // A mensagem de status √© Not Found
```

Se voc√™ precisar apenas de alguns dos valores da tupla, ignore partes da tupla com um sublinhado (`_`) ao decompor a tupla:

```swift
let (justTheStatusCode, _) = http404Error // [!code word:_]
print("O c√≥digo de status √© \(justTheStatusCode)") // O c√≥digo de status √© 404
```

Alternativamente, acesse os valores de elementos individuais em uma tupla usando n√∫meros de √≠ndice come√ßando em zero:

```swift
print("O c√≥digo de status √© \(http404Error.0)") // O c√≥digo de status √© 404
print("A mensagem de status √© \(http404Error.1)") // A mensagem de status √© Not Found
```

Voc√™ pode nomear os elementos individuais em uma tupla quando a tupla √© definida:

```swift
let http200status = (statusCode: 200, description: "OK")
```

Se voc√™ nomear os elementos em uma tupla, poder√° usar os nomes dos elementos para acessar os valores desses elementos:

```swift
print("O c√≥digo de status √© \(http200status.statusCode)") // O c√≥digo de status √© 200
print("A mensagem de status √© \(http200status.description)") // A mensagem de status √© OK
```

As tuplas s√£o particularmente √∫teis como valores de retorno das fun√ß√µes. Uma fun√ß√£o que tenta recuperar uma p√°gina da web pode retornar o tipo de tupla `(Int, String){:swift}` para descrever o sucesso ou falha da recupera√ß√£o da p√°gina. Ao retornar uma tupla com dois valores distintos, cada um de um tipo diferente, a fun√ß√£o fornece informa√ß√µes mais √∫teis sobre seu resultado do que se pudesse retornar apenas um √∫nico valor de um √∫nico tipo. Para mais informa√ß√µes, consulte [Fun√ß√µes com V√°rios Valores de Retorno]().

<Callout title="Nota">
  Tuplas s√£o √∫teis para grupos simples de valores relacionados. Eles n√£o s√£o
  adequados para a cria√ß√£o de estruturas de dados complexas. Se sua estrutura de
  dados provavelmente ser√° mais complexa, modele-a como uma classe ou estrutura,
  em vez de como uma tupla. Para mais informa√ß√µes, consulte [Estruturas e
  Classes]().
</Callout>

## Opcionais

Voc√™ usa _opcionais_ em situa√ß√µes em que um valor pode estar ausente. Um opcional representa duas possibilidades: ou h√° um valor, e voc√™ pode desembrulhar o opcional para acessar esse valor, ou n√£o h√° nenhum valor.

<Callout title="Nota">
  O conceito de opcionais n√£o existe em C ou Objective-C. A coisa mais pr√≥xima
  no Objective-C √© a capacidade de retornar `nil` de um m√©todo que, de outra
  forma, retornaria um objeto, com `nil` significando ‚Äúa aus√™ncia de um objeto
  v√°lido‚Äù. No entanto, isso s√≥ funciona para objetos, n√£o funciona para
  estruturas, tipos C b√°sicos ou valores de enumera√ß√£o. Para esses tipos, os
  m√©todos Objective-C normalmente retornam um valor especial (como `NSNotFound`)
  para indicar a aus√™ncia de um valor. Essa abordagem assume que o chamador do
  m√©todo sabe que h√° um valor especial para testar e se lembra de verific√°-lo.
  Os opcionais do Swift permitem que voc√™ indique a aus√™ncia de um valor para
  _qualquer tipo_, sem a necessidade de constantes especiais.
</Callout>

Aqui est√° um exemplo de como os opcionais podem ser usados para lidar com a aus√™ncia de um valor. O tipo `Int` do Swift tem um inicializador que tenta converter um valor `String` em um valor `Int`. No entanto, nem toda string pode ser convertida em um inteiro. A string "123" pode ser convertida no valor num√©rico 123, mas a string "hello, world" n√£o tem um valor num√©rico √≥bvio para converter.

O exemplo abaixo usa o inicializador para tentar converter uma `String` em um `Int`:

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber √© inferido para o tipo "Int?", ou "optional Int"
```

Como o inicializador pode falhar, ele retorna um `Int` opcional, em vez de um `Int`. Um `Int` opcional √© escrito como `Int?`, n√£o `Int`. O ponto de interroga√ß√£o indica que o valor que ele cont√©m √© opcional, o que significa que pode conter algum valor `Int`, ou pode n√£o conter nenhum valor. (N√£o pode conter mais nada, como um valor `Bool` ou um valor `String`. Ou √© um `Int`, ou n√£o √© nada.)

### `nil`

Voc√™ define uma vari√°vel opcional para um estado sem valor atribuindo-lhe o valor especial `nil`:

```swift
var serverResponseCode: Int? = 404
// serverResponseCode tem o valor atual do tipo Int de 404
serverResponseCode = nil
// serverResponseCode agora n√£o tem nenhum valor
```

<Callout title="Nota">
  Voc√™ n√£o pode usar `nil` com constantes e vari√°veis n√£o opcionais. Se uma
  constante ou vari√°vel em seu c√≥digo precisar trabalhar com a aus√™ncia de um
  valor sob certas condi√ß√µes, sempre declare-a como um valor opcional do tipo
  apropriado.
</Callout>

Se voc√™ definir uma vari√°vel opcional sem fornecer um valor padr√£o, a vari√°vel ser√° automaticamente definida como `nil` para voc√™:

```swift
var surveyAnswer: String?
// surveyAnswer √© automaticamente definida como nil
```

<Callout title="Nota">

O `nil` de Swift n√£o √© o mesmo que o `nil` no Objective-C. No Objective-C, `nil` √© um ponteiro para um objeto inexistente. Em Swift, `nil` n√£o √© um ponteiro‚Äî√© a aus√™ncia de um valor de um determinado tipo. Opcionais de qualquer tipo podem ser definidos como `nil`, n√£o apenas tipos de objeto.

</Callout>

### Declara√ß√µes `if` e Desembrulhamento For√ßado

Voc√™ pode usar uma instru√ß√£o `if` para descobrir se um opcional cont√©m um valor comparando o opcional com `nil`. Voc√™ realiza essa compara√ß√£o com o operador ‚Äúigual a‚Äù (`==`) ou o operador ‚Äún√£o igual a‚Äù (`!=`).

Se um opcional tiver um valor, ele ser√° considerado ‚Äún√£o igual a‚Äù `nil`:

```swift
if convertedNumber != nil {
  print("convertedNumber tem um valor inteiro.") // convertedNumber tem um valor inteiro.
}
```

Quando tiver certeza de que o opcional cont√©m um valor, voc√™ pode acessar seu valor subjacente adicionando um ponto de exclama√ß√£o (`!`) At√© o final do nome do opcional. O ponto de exclama√ß√£o efetivamente diz: ‚ÄúEu sei que este opcional definitivamente tem um valor, por favor, use-o.‚Äù Isso √© conhecido como desembrulhamento for√ßado do valor do opcional:

```swift
if convertedNumber != nil {
  print("convertedNumber tem um valor inteiro de \(convertedNumber!).") // convertedNumber tem um valor inteiro de \(convertedNumber!).
}
```

Para mais sobre a instru√ß√£o if, consulte [Fluxo de Controle](../control-flow/index.mdx).

<Callout title="Nota">
  Tentando usar `!` Para acessar um valor opcional inexistente aciona um erro de
  tempo de execu√ß√£o. Sempre certifique-se de que um opcional contenha um valor
  diferente de nulo antes de usar `!` Para for√ßar o desembrulhar seu valor.
</Callout>

### Liga√ß√£o Opcional

Voc√™ usa a _liga√ß√£o opcional_ para descobrir se um opcional cont√©m um valor e, em caso afirmativo, para disponibilizar esse valor como uma constante ou vari√°vel tempor√°ria. A liga√ß√£o opcional pode ser usada com instru√ß√µes `if` e `while` para verificar um valor dentro de um opcional e para extrair esse valor em uma constante ou vari√°vel, como parte de uma √∫nica a√ß√£o. As instru√ß√µes `if` e `while` s√£o descritas com mais detalhes no [Fluxo de Controle](../control-flow/index.mdx).

Escreva uma liga√ß√£o opcional para uma instru√ß√£o `if` da seguinte forma:

```swift
// [!code word:constantName]
// [!code word:someOptional]
// [!code word:statements]
if let constantName = someOptional {
  statements
}
```

Voc√™ pode reescrever o exemplo `possibleNumber` da se√ß√£o [Opcionais](./optionals.mdx) para usar a vincula√ß√£o opcional em vez de desembrulhamento for√ßado:

```swift lineNumbers
if let actualNumber = Int(possibleNumber) {
  print("A string \"\(possibleNumber)\" tem um valor inteiro de \(actualNumber)")
} else {
  print("A string \"\(possibleNumber)\" n√£o pode ser convertida para um inteiro")
}

// Retorna: A string "123" tem um valor inteiro de 123
```

Este c√≥digo pode ser lido como:

‚ÄúSe o `Int` opcional retornado por `Int(possibleNumber){:swift}` contiver um valor, defina uma nova constante chamada `actualNumber` para o valor contido no opcional.‚Äù

Se a convers√£o for bem-sucedida, a constante `actualNumber` ficar√° dispon√≠vel para uso no primeiro ramo da instru√ß√£o `if`. J√° foi inicializado com o valor contido no opcional e, portanto, voc√™ n√£o usa o sufixo `!` para acessar seu valor. Neste exemplo, `actualNumber` √© simplesmente usado para imprimir o resultado da convers√£o.

Se voc√™ n√£o precisar se referir √† constante ou vari√°vel original e opcional depois de acessar o valor que ela cont√©m, poder√° usar o mesmo nome para a nova constante ou vari√°vel:

```swift
let myNumber = Int(possibleNumber) // Aqui, myNumber √© um Int opcional
if let myNumber = myNumber {
  // Aqui, myNumber √© obrigatoriamente Int
  print("Meu numero √© \(myNumber)")
}
```

Este c√≥digo come√ßa verificando se `myNumber` cont√©m um valor, assim como o c√≥digo no exemplo anterior. Se `myNumber` tiver um valor, o valor de uma nova constante chamada `myNumber` √© definido para esse valor. Dentro do corpo da instru√ß√£o `if`, escrever `myNumber` refere-se a essa nova constante n√£o opcional. Antes do in√≠cio da instru√ß√£o `if` e ap√≥s seu fim, escrever `myNumber` refere-se √† constante inteira opcional.

Como esse tipo de c√≥digo √© t√£o comum, voc√™ pode usar uma ortografia mais curta para desembrulhar um valor opcional: escreva apenas o nome da constante ou vari√°vel que voc√™ est√° desembrulhando. A nova constante ou vari√°vel n√£o embrulhada usa implicitamente o mesmo nome que o valor opcional.

```swift
if let myNumber {
    print("Meu numero √© \(myNumber)")
}
```

Voc√™ pode usar constantes e vari√°veis com liga√ß√£o opcional. Se voc√™ quisesse manipular o valor de `myNumber` dentro do primeiro ramo da instru√ß√£o `if`, voc√™ poderia escrever `if var myNumber{:swift}` em vez disso, e o valor contido no opcional seria disponibilizado como uma vari√°vel em vez de uma constante. As altera√ß√µes que voc√™ faz no `myNumber` dentro do corpo da instru√ß√£o `if` se aplicam apenas a essa vari√°vel local, n√£o √† constante ou vari√°vel original e opcional que voc√™ desembrulhou.

Voc√™ pode incluir quantas liga√ß√µes opcionais e condi√ß√µes booleanas precisar em uma √∫nica instru√ß√£o `if`, separadas por v√≠rgulas. Se qualquer um dos valores nas liga√ß√µes opcionais for nulo ou qualquer condi√ß√£o booleana for avaliada como falsa, a condi√ß√£o da instru√ß√£o `if` inteira √© considerada falsa. As seguintes declara√ß√µes `if` s√£o equivalentes:

```swift lineNumbers
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 { // [!code focus]
  print("\(firstNumber) < \(secondNumber) < 100") // 4 < 42 < 100
}

// [!code focus:3]
if let firstNumber = Int("4") {
  if let secondNumber = Int("42") {
    if firstNumber < secondNumber && secondNumber < 100 {
      print("\(firstNumber) < \(secondNumber) < 100") // 4 < 42 < 100
    }
  }
}
```

<Callout title="Nota">
  Constantes e vari√°veis criadas com liga√ß√£o opcional em uma instru√ß√£o `if`
  est√£o dispon√≠veis apenas dentro do corpo da instru√ß√£o `if`. Em contraste, as
  constantes e vari√°veis criadas com uma instru√ß√£o de guarda est√£o dispon√≠veis
  nas linhas de c√≥digo que seguem a instru√ß√£o de guarda, conforme descrito em
  [Sa√≠da Antecipada]().
</Callout>

### Opcionais implicitamente desembrulhados

Conforme descrito acima, os opcionais indicam que uma constante ou vari√°vel pode ter ‚Äúnenhum valor‚Äù. Os opcionais podem ser verificados com uma instru√ß√£o `if` para ver se existe um valor e podem ser desembrulhados condicionalmente com liga√ß√£o opcional para acessar o valor do opcional, se existir.

√Äs vezes fica claro na estrutura de um programa que um opcional sempre ter√° um valor, depois que esse valor for definido pela primeira vez. Nesses casos, √© √∫til remover a necessidade de verificar e desembrulhar o valor do opcional toda vez que for acessado, porque pode-se assumir com seguran√ßa que tem um valor o tempo todo.

Esses tipos de opcionais s√£o definidos como opcionais implicitamente desembrulhados. Voc√™ escreve um opcional implicitamente desembrulhado colocando um ponto de exclama√ß√£o (`String!`) Em vez de um ponto de interroga√ß√£o (`String?`) Ap√≥s o tipo que voc√™ deseja tornar opcional. Em vez de colocar um ponto de exclama√ß√£o ap√≥s o nome do opcional quando voc√™ o usa, voc√™ coloca um ponto de exclama√ß√£o ap√≥s o tipo do opcional quando o declara.

Opcionais implicitamente desembrulhados s√£o √∫teis quando o valor de um opcional √© confirmado para existir imediatamente ap√≥s o opcional ser definido pela primeira vez e podem definitivamente ser assumidos como existindo em todos os pontos depois disso. O uso principal de opcionais implicitamente desembrulhados no Swift √© durante a inicializa√ß√£o da classe, conforme descrito em [Refer√™ncias n√£o pertencentes e Propriedades Opcionais Implicitamente Desembrulhadas]().

Um opcional implicitamente desembrulhado √© um opcional normal nos bastidores, mas tamb√©m pode ser usado como um valor n√£o opcional, sem a necessidade de desembrulhar o valor opcional toda vez que for acessado. O exemplo a seguir mostra a diferen√ßa de comportamento entre uma string opcional e uma string opcional implicitamente desembrulhada ao acessar seu valor agrupado como uma `String` expl√≠cita:

```swift lineNumbers
let possibleString: String? = "Uma string opcional."
let forcedString: string = possibleString! // Requer um ponto de exclama√ß√£o

let assumedString: String! = "Uma string opcional implicitamente desembrulhada."
let implicitString: String = assumedString // N√£o precisa de ponto de exclama√ß√£o
```

Voc√™ pode pensar em um opcional implicitamente desembrulhado como dando permiss√£o para que o opcional seja desembrulhado √† for√ßa, se necess√°rio. Quando voc√™ usa um valor opcional implicitamente desembrulhado, o Swift primeiro tenta us√°-lo como um valor opcional comum; se n√£o puder ser usado como um opcional, o Swift desembrulha √† for√ßa o valor. No c√≥digo acima, o valor opcional `assumedString` √© desembrulhado √† for√ßa antes de atribuir seu valor a `implicitString` porque `implicitString` tem um tipo de `String` expl√≠cito e n√£o opcional. No c√≥digo abaixo, `optionalString` n√£o tem um tipo expl√≠cito, ent√£o √© um opcional comum.

```swift
let optionalString = assumedString
// O tipo de optionalString √© "String?" E assumedString n√£o √© desembrulhado √† for√ßa.
```

Se um opcional implicitamente desembrulhado for nulo e voc√™ tentar acessar seu valor agrupado, voc√™ acionar√° um erro de tempo de execu√ß√£o. O resultado √© exatamente o mesmo que se voc√™ colocasse um ponto de exclama√ß√£o ap√≥s um opcional normal que n√£o contenha um valor.

Voc√™ pode verificar se um opcional implicitamente desembrulhado √© nulo da mesma forma que voc√™ verifica um opcional normal:

```swift
if assumedString != nil {
  print(assumedString!) // Uma string opcional implicitamente desembrulhada.
}
```

Voc√™ tamb√©m pode usar um opcional implicitamente desembrulhado com liga√ß√£o opcional, para verificar e desembrulhar seu valor em uma √∫nica instru√ß√£o:

```swift
if let definiteString = assumedString {
  print(definiteString) // Uma string opcional implicitamente desembrulhada.
}
```

<Callout title="Nota">
  N√£o use um opcional implicitamente desembrulhado quando houver a possibilidade
  de uma vari√°vel se tornar nula em um ponto posterior. Sempre use um tipo
  opcional normal se precisar verificar um valor nulo durante a vida √∫til de uma
  vari√°vel.
</Callout>

## Tratamento de Erros [#error-handling]

Voc√™ usa o _tratamento de erros_ para responder √†s condi√ß√µes de erro que seu programa pode encontrar durante a execu√ß√£o.

Em contraste com os opcionais, que podem usar a presen√ßa ou aus√™ncia de um valor para comunicar o sucesso ou a falha de uma fun√ß√£o, o tratamento de erros permite determinar a causa subjacente da falha e, se necess√°rio, propagar o erro para outra parte do seu programa.

Quando uma fun√ß√£o encontra uma condi√ß√£o de erro, ela _lan√ßa_ um erro. O chamador dessa fun√ß√£o pode ent√£o detectar o erro e responder adequadamente.

```swift
func canThrowAnError() throws { // [!code word:throws]
  // Esta fun√ß√£o pode ou n√£o lan√ßar um erro
}
```

Uma fun√ß√£o indica que pode lan√ßar um erro ao incluir a palavra-chave `throws` em sua declara√ß√£o. Quando voc√™ chama uma fun√ß√£o que pode lan√ßar um erro, voc√™ antecipa a palavra-chave `try` √† express√£o.

O Swift propaga automaticamente os erros fora de seu escopo atual at√© que sejam tratados por uma cl√°usula de captura.

```swift lineNumbers
do { // [!code word:do:1]
  try canThrowAnError() // [!code word:try] nenhum erro √© lan√ßado
} catch { // [!code word:catch]
  // um erro √© lan√ßado
}
```

Uma instru√ß√£o do cria um novo escopo de conten√ß√£o, o que permite que erros sejam propagados para uma ou mais cl√°usulas `catch`.

Aqui est√° um exemplo de como o tratamento de erros pode ser usado para responder a diferentes condi√ß√µes de erro:

```swift lineNumbers
func makeASandwich() throws {
  // ...
}

do {
  try makeASandwich()
  eatASandwich()
} catch SandwichError.outOfCleanDishes { // [!code focus]
  washDishes()
} catch SandwichError.missingIngredients(let ingredients) { // [!code focus]
  buyGroceries(ingredients)
}
```

Neste exemplo, a fun√ß√£o `makeASandwich(){:swift}` lan√ßar√° um erro se n√£o houver pratos limpos dispon√≠veis ou se algum ingrediente estiver faltando. Como `makeASandwich(){:swift}` pode lan√ßar um erro, a chamada de fun√ß√£o √© envolvida em uma express√£o try. Ao envolver a chamada de fun√ß√£o em uma instru√ß√£o do, quaisquer erros lan√ßados ser√£o propagados para as cl√°usulas `catch` fornecidas.

Se nenhum erro for lan√ßado, a fun√ß√£o `eatASandwich(){:swift}` ser√° chamada. Se um erro for lan√ßado e corresponder ao caso `SandwichError.outOfCleanDishes`, a fun√ß√£o `washDishes(){:swift}` ser√° chamada. Se um erro for lan√ßado e corresponder ao caso `SandwichError.missingIngredients`, a fun√ß√£o `buyGroceries(_:){:swift}` ser√° chamada com o valor `[String]` associado capturado pelo padr√£o `catch`.

Arremesso, captura e propaga√ß√£o de erros √© abordado com mais detalhes no [Tratamento de Erros](/docs/language-guide/error-handling).

## Afirma√ß√µes e pr√©-condi√ß√µes

Afirma√ß√µes e pr√©-condi√ß√µes s√£o verifica√ß√µes que acontecem em tempo de execu√ß√£o. Voc√™ os usa para garantir que uma condi√ß√£o essencial seja satisfeita antes de executar qualquer outro c√≥digo. Se a condi√ß√£o booleana na afirma√ß√£o ou pr√©-condi√ß√£o for avaliada como verdadeira, a execu√ß√£o do c√≥digo continuar√° como de costume. Se a condi√ß√£o for avaliada como falsa, o estado atual do programa √© inv√°lido; a execu√ß√£o do c√≥digo termina e seu aplicativo √© encerrado.

Voc√™ usa afirma√ß√µes e pr√©-condi√ß√µes para expressar as suposi√ß√µes que faz e as expectativas que tem durante a codifica√ß√£o, para que possa inclu√≠-las como parte do seu c√≥digo. As afirma√ß√µes ajudam voc√™ a encontrar erros e suposi√ß√µes incorretas durante o desenvolvimento, e as pr√©-condi√ß√µes ajudam voc√™ a detectar problemas na produ√ß√£o.

Al√©m de verificar suas expectativas em tempo de execu√ß√£o, as afirma√ß√µes e pr√©-condi√ß√µes tamb√©m se tornam uma forma √∫til de documenta√ß√£o dentro do c√≥digo. Ao contr√°rio das condi√ß√µes de erro discutidas em [Tratamento de Erros](#error-handling) acima, as afirma√ß√µes e pr√©-condi√ß√µes n√£o s√£o usadas para erros recuper√°veis ou esperados. Como uma afirma√ß√£o ou pr√©-condi√ß√£o com falha indica um estado inv√°lido do programa, n√£o h√° como capturar uma afirma√ß√£o com falha.

Usar asser√ß√µes e pr√©-condi√ß√µes n√£o √© um substituto para projetar seu c√≥digo de tal forma que seja improv√°vel que surjam condi√ß√µes inv√°lidas. No entanto, us√°-los para impor dados e status v√°lidos faz com que seu aplicativo termine de forma mais previs√≠vel se ocorrer um estado inv√°lido e ajuda a tornar o problema mais f√°cil de depurar. Interromper a execu√ß√£o assim que um estado inv√°lido for detectado tamb√©m ajuda a limitar os danos causados por esse estado inv√°lido.

A diferen√ßa entre asser√ß√µes e pr√©-condi√ß√µes √© quando elas s√£o verificadas: As asser√ß√µes s√£o verificadas apenas em compila√ß√µes de depura√ß√£o, mas as pr√©-condi√ß√µes s√£o verificadas em compila√ß√µes de depura√ß√£o e produ√ß√£o. Em compila√ß√µes de produ√ß√£o, a condi√ß√£o dentro de uma afirma√ß√£o n√£o √© avaliada. Isso significa que voc√™ pode usar quantas afirma√ß√µes quiser durante seu processo de desenvolvimento, sem afetar o desempenho na produ√ß√£o

### Depura√ß√£o com Afirma√ß√µes

Voc√™ escreve uma afirma√ß√£o chamando a fun√ß√£o [`assert(_:_:file:line:){:swift}`](https://developer.apple.com/documentation/swift/1541112-assert) da biblioteca padr√£o do Swift. Voc√™ passa para esta fun√ß√£o uma express√£o que √© avaliada como verdadeira ou falsa e uma mensagem para exibir se o resultado da condi√ß√£o for falso. Por exemplo:

```swift
let age = -3
assert(age >= 0, "A idade de uma pessoa n√£o pode ser menor que zero.")
// Esta afirma√ß√£o falha porque -3 n√£o √© >= 0.
```

Neste exemplo, a execu√ß√£o do c√≥digo continua se `age >= 0{:swift}` for avaliada como verdadeira, ou seja, se o valor da idade n√£o for negativo. Se o valor da idade for negativo, como no c√≥digo acima, ent√£o `age >= 0{:swift}` √© avaliada como falsa e a afirma√ß√£o falha, encerrando o aplicativo.

Voc√™ pode omitir a mensagem de afirma√ß√£o, por exemplo, quando ela apenas repetiria a condi√ß√£o como prosa.

```swift
assert(age >= 0)
```

Se o c√≥digo j√° verificar a condi√ß√£o, use a fun√ß√£o [`assertionFailure(_:file:line:){:swift}`](https://developer.apple.com/documentation/swift/1539616-assertionfailure) para indicar que uma afirma√ß√£o falhou. Por exemplo:

```swift lineNumbers
if age > 10 {
  print("Voc√™ pode andar de montanha-russa ou de roda-gigante.")
} else if age >= 0 {
  print("Voc√™ pode andar na roda-gigante.")
} else {
  assertionFailure("A idade de uma pessoa n√£o pode ser menor que zero.")
}
```

### Ampor as Pr√©-Condi√ß√µes

Use uma pr√©-condi√ß√£o sempre que uma condi√ß√£o tiver o potencial de ser falsa, mas _definitivamente_ deve ser verdadeira para que seu c√≥digo continue a execu√ß√£o. Por exemplo, use uma pr√©-condi√ß√£o para verificar se um subscrito n√£o est√° fora dos limites ou para verificar se uma fun√ß√£o passou um valor v√°lido.

Voc√™ escreve uma pr√©-condi√ß√£o chamando a fun√ß√£o [`precondition(_:_:file:line:){:swift}`](https://developer.apple.com/documentation/swift/1540960-precondition). Voc√™ passa para esta fun√ß√£o uma express√£o que √© avaliada como verdadeira ou falsa e uma mensagem para exibir se o resultado da condi√ß√£o for falso. Por exemplo:

```swift
// Na implementa√ß√£o de um subscript...
precondition(index > 0, "O √≠ndice deve ser maior que zero.")
```

Voc√™ tamb√©m pode chamar a fun√ß√£o [`preconditionFailure(_:file:line:){:swift}`](https://developer.apple.com/documentation/swift/1539374-preconditionfailure) para indicar que ocorreu uma falha, por exemplo, se o caso padr√£o de um `switch` foi tomado, mas todos os dados de entrada v√°lidos devem ter sido tratados por um dos outros casos do `switch`.

<Callout title="Nota">
Se voc√™ compilar no modo desmarcado (`-Ounchecked`), as pr√©-condi√ß√µes n√£o s√£o marcadas. O compilador assume que as pr√©-condi√ß√µes s√£o sempre verdadeiras e otimiza seu c√≥digo de acordo. No entanto, a fun√ß√£o `fatalError(_:file:line:){:swift}` sempre interrompe a execu√ß√£o, independentemente das configura√ß√µes de otimiza√ß√£o.

Voc√™ pode usar a fun√ß√£o `fatalError(_:file:line:){:swift}` durante a prototipagem e o desenvolvimento inicial para criar stubs para funcionalidades que ainda n√£o foram implementadas, escrevendo `fatalError("Unimplemented"){:swift}` como a implementa√ß√£o de stub. Como os erros fatais nunca s√£o otimizados, ao contr√°rio de asser√ß√µes ou pr√©-condi√ß√µes, voc√™ pode ter certeza de que a execu√ß√£o sempre ser√° interrompida se encontrar uma implementa√ß√£o de `stub`.

</Callout>
