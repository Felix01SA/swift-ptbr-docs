---
title: Operadores B√°sicos
description: Os superpoderes da programa√ß√£o. Somam, comparam e decidem tudo! üí•
---

import { RemainderOperatorExemple } from "@/components/remainder-operator-exemple";

Um operador √© um s√≠mbolo ou frase especial que voc√™ usa para verificar, alterar ou combinar valores. Por exemplo, o operador de adi√ß√£o (`+`) adiciona dois n√∫meros, como em `let i = 1 + 2{:swift}`, e o operador l√≥gico AND (`&&`) combina dois valores booleanos, como em `if enteredDoorCode && passedRetinaScan{:swift}`.

O Swift suporta os operadores que voc√™ j√° deve conhecer de linguagens como C e melhora v√°rios recursos para eliminar erros comuns de codifica√ß√£o. O operador de atribui√ß√£o (`=`) n√£o retorna um valor, para evitar que ele seja usado erroneamente quando o operador igual ao operador (`==`) for pretendido. Os operadores aritm√©ticos (`+`, `-`, `*`, `/`, `%` e assim por diante) detectam e n√£o permitem o estouro de valor, para evitar resultados inesperados ao trabalhar com n√∫meros que se tornam maiores ou menores do que o intervalo de valores permitido do tipo que os armazena. Voc√™ pode optar por avaliar o comportamento de estouro usando os operadores de estouro do Swift, conforme descrito em [Overflow Operators]().

O Swift tamb√©m fornece operadores de intervalo que n√£o s√£o encontrados em C, como `a..<b{:swift}` e `a...b{:swift}`, como um atalho para expressar um intervalo de valores.

Este cap√≠tulo descreve os operadores comuns no Swift. [Operadores Avan√ßados]() cobrem os operadores avan√ßados do Swift e descrevem como definir seus pr√≥prios operadores personalizados e implementar os operadores padr√£o para seus pr√≥prios tipos personalizados.

## Terminologia [#terminology]

Os operadores s√£o un√°rios, bin√°rios ou tern√°rios:

- Operadores _un√°rios_ operam em um √∫nico alvo (como `-a`). Operadores de _prefixo_ un√°rio aparecem imediatamente antes de seu alvo (como `!b`), e operadores de `p√≥s-fixo` un√°rios aparecem imediatamente ap√≥s seu alvo (como `c!`).
- Operadores bin√°rios operam em dois alvos (como `2 + 3{:swift}`) e s√£o _infixos_ porque aparecem entre seus dois alvos.
- Operadores tern√°rios operam em tr√™s alvos. Como C, Swift tem apenas um operador tern√°rio, o operador condicional tern√°rio (`a ? b : c{:swift}`).

Os valores que os operadores afetam s√£o operandos. Na express√£o `1 + 2{:swift}`, o s√≠mbolo `+` √© um operador infixo e seus dois operandos s√£o os valores 1 e 2.

## Operador de Atribui√ß√£o [#assignment-operador]

O operador de atribui√ß√£o (`a = b`) inicializa ou atualiza o valor de `a` com o valor de `b`:

```swift
let b = 10
var a = 5
a = b // a agora √© igual a 10
```

Se o lado direito da atribui√ß√£o for uma tupla com v√°rios valores, seus elementos podem ser decompostos em v√°rias constantes ou vari√°veis ao mesmo tempo:

```swift
let (x, y) = (1, 2) // x √© igual a 1, e y √© igual a 2
```

Ao contr√°rio do operador de atribui√ß√£o em C e Objective-C, o operador de atribui√ß√£o em Swift n√£o retorna um valor. A seguinte declara√ß√£o n√£o √© v√°lida:

```swift
if x = y {
  // Isso n√£o √© v√°lido, porque x = y n√£o retorna um valor.
}
```

Esse recurso impede que o operador de atribui√ß√£o (`=`) seja usado por acidente quando o igual ao operador (`==`) √© realmente pretendido. Ao tornar `if x = y{:swift}` inv√°lido, o Swift ajuda voc√™ a evitar esses tipos de erros em seu c√≥digo.

## Operadores Aritm√©ticos [#arithmetic-operators]

O Swift suporta os quatro operadores _aritm√©ticos_ padr√£o para todos os tipos de n√∫meros:

- Adi√ß√£o (`+`)
- Subtra√ß√£o (`-`)
- Multiplica√ß√£o (`*`)
- Divis√£o (`/`)

```swift
1 + 2       // igual a 3
5 - 3       // igual a 2
2 * 3       // igual a 6
10.0 / 2.5  // igual a 4.0
```

Ao contr√°rio dos operadores aritm√©ticos em C e Objective-C, os operadores aritm√©ticos Swift n√£o permitem que os valores transbordem por padr√£o. Voc√™ pode optar pelo comportamento de estouro de valor usando os operadores de estouro do Swift (como a &+ b). Veja [Operadores de Estouro]().

O operador de adi√ß√£o tamb√©m √© suportado para concatena√ß√£o de `String`:

```swift
"ol√°, " + "mundo" // igual a "Ol√°, mundo"
```

### Operador de resto [#remainder-operator]

O operador restante (`a % b{:swift}`) determina quantos m√∫ltiplos de `b` caber√£o dentro de `a` e retorna o valor que sobrou (conhecido como o restante).

<Callout title="Nota">
  O operador restante (`%`) tamb√©m √© conhecido como operador m√≥dulo em outros
  idiomas. No entanto, seu comportamento no Swift para n√∫meros negativos
  significa que, estritamente falando, √© um resto em vez de uma opera√ß√£o de
  m√≥dulo.
</Callout>

√â assim que o operador restante funciona. Para calcular `9 % 4{:swift}`, voc√™ primeiro calcula quantos 4 caber√£o dentro de 9:

<RemainderOperatorExemple />

Voc√™ pode colocar dois 4 dentro de 9, e o restante √© 1 (mostrado em laranja).

Em Swift, isso seria escrito como:

```swift
9 % 4 // igual a 1
```

Para determinar a resposta para `a % b{:swift}`, o operador `%` calcula a seguinte equa√ß√£o e retorna o restante como sua sa√≠da:

```swift
a = (b * algum multiplicador) + remainder
```

Onde _algum multiplicador_ √© o maior n√∫mero de m√∫ltiplos de `b` que caber√£o dentro de `a`.

Inserir 9 e 4 nesta equa√ß√£o produz:

```swift
9 = (4 * 2) + 1
```

O mesmo m√©todo √© aplicado ao calcular o restante para um valor negativo de um:

```swift
-9 % 4 // igual a -1
```

Inserir -9 e 4 na equa√ß√£o produz:

```swift
-9 = (4 * -2) + -1
```

Dando um valor residual de -1.

O sinal de `b` √© ignorado para valores negativos de `b`. Isso significa que `a % b{:swift}` e `a % -b{:swift}` sempre d√£o a mesma resposta.

### Operador Un√°rio de Menos [#unary-minus-operator]

O sinal de um valor num√©rico pode ser alternado usando um prefixado `-`, conhecido como _operador un√°rio de menos_:

```swift
let three = 3
let minusThree = -three // igual a -3
let plusThree = -minusThree // igual a 3, ou "menos menos tr√™s"
```

O operador un√°rio menos (`-`) √© precedido diretamente antes do valor em que opera, sem nenhum espa√ßo em branco.

### Operador Un√°rio de Mais [#unary-plus-operator]

O _operador un√°rio de mais_ (`+`) simplesmente retorna o valor em que opera, sem qualquer altera√ß√£o:

```swift
let minusSix = -6
let alsoMinusSix = +minusSix // igual a -6
```

Embora o _operador un√°rio mais_ na verdade n√£o fa√ßa nada, voc√™ pode us√°-lo para fornecer simetria em seu c√≥digo para n√∫meros positivos ao tamb√©m usar o operador un√°rio menos para n√∫meros negativos.

## Operadores de Atribui√ß√£o Composta [#compound-assignment-operators]

Como C, Swift fornece operadores de atribui√ß√£o compostos que combinam atribui√ß√£o (`=`) com outra opera√ß√£o. Um exemplo √© o operador de atribui√ß√£o de adi√ß√£o (`+=`):

```swift
var a = 1
a += 2 // agora a √© igual a 3
```

A express√£o `a += 2{:swift}` √© uma abrevia√ß√£o para `a = a + 2{:swift}`. Efetivamente, a adi√ß√£o e a atribui√ß√£o s√£o combinadas em um operador que executa ambas as tarefas ao mesmo tempo.

<Callout title="Nota">
Os operadores de atribui√ß√£o composta n√£o retornam um valor. Por exemplo, voc√™ n√£o pode escrever `let b = a += 2{:swift}`.
</Callout>

Para obter informa√ß√µes sobre os operadores fornecidos pela biblioteca padr√£o Swift, consulte [Declara√ß√µes de Operadores](https://developer.apple.com/documentation/swift/operator_declarations).

## Operadores de Compara√ß√£o [#comparison-operators]

O Swift suporta os seguintes operadores de compara√ß√£o:

- Igual a (`a == b{:swift}`)
- N√£o √© igual a (`a != b{:swift}`)
- Maior que (`a > b{:swift}`)
- Menos do que (`a < b{:swift}`)
- Maior que ou igual a (`a >= b{:swift}`)
- Menor ou igual a (`a <= b{:swift}`)

<Callout title="Nota">
  Swift tamb√©m fornece dois operadores de identidade (`===` e `!==`), que voc√™
  usa para testar se duas refer√™ncias de objeto se referem √† mesma inst√¢ncia de
  objeto. Para mais informa√ß√µes, consulte [Operadores de Identidade]().
</Callout>

Cada um dos operadores de compara√ß√£o retorna um valor `Bool` para indicar se a declara√ß√£o √© verdadeira ou n√£o:

```swift lineNumbers
1 == 1    // verdadeiro porque 1 √© igual a 1
2 != 1    // verdadeiro porque 2 √© diferente de 1
2 > 1     // verdadeiro porque 2 √© maior que 1
1 < 2     // verdadeiro porque 1 √© menor que 2
1 >= 1    // verdadeiro porque 1 √© maior ou igual a 1
2 <= 1    // falso porque 2 n√£o √© menor ou igual a 1
```

Operadores de compara√ß√£o s√£o frequentemente usados em instru√ß√µes condicionais, como a instru√ß√£o `if`:

```swift lineNumbers
let name = "mundo"
if name == "mundo" {
  print("ol√°, mundo")
} else {
  print("Sinto muito \(name), mas n√£o te reconhe√ßo")
}

// Retorna "ol√°, mundo", porque name √© igual a "mundo".
```

Para mais sobre a instru√ß√£o `if`, consulte [Fluxo de Controle](/docs/language-guide/control-flow).

Voc√™ pode comparar duas tuplas se elas tiverem o mesmo tipo e o mesmo n√∫mero de valores. As tuplas s√£o comparadas da esquerda para a direita, um valor de cada vez, at√© que a compara√ß√£o encontre dois valores que n√£o s√£o iguais. Esses dois valores s√£o comparados, e o resultado dessa compara√ß√£o determina o resultado geral da compara√ß√£o da tupla. Se todos os elementos s√£o iguais, ent√£o as pr√≥prias tuplas s√£o iguais. Por exemplo:

```swift
(1, "zebra") < (2, "ma√ß√£")          // verdadeiro porque 1 √© menor que 2; "zebra" e "ma√ß√£" n√£o s√£o comparados
(3, "ma√ß√£") < (3, "p√°ssaro")        // verdadeiro porque 3 √© igual a 3 e "ma√ßa" e manor q "p√°ssaro"
(4, "cachorro") == (4, "cachorro")  // verdadeiro porque 4 √© igual a 4 e "cachorro" √© igual a "cachorro"
```

No exemplo acima, voc√™ pode ver o comportamento de compara√ß√£o da esquerda para a direita na primeira linha. Como 1 √© menor que 2, `(1, "zebra")` √© considerado menor que `(2, "ma√ß√£")`, independentemente de quaisquer outros valores nas tuplas. N√£o importa que "zebra" n√£o seja menos do que "ma√ß√£", porque a compara√ß√£o j√° √© determinada pelos primeiros elementos das tuplas. No entanto, quando os primeiros elementos das tuplas s√£o os mesmos, seus segundos elementos s√£o comparados - isso √© o que acontece na segunda e na terceira linha.

As tuplas podem ser comparadas com um determinado operador somente se o operador puder ser aplicado a cada valor nas respectivas tuplas. Por exemplo, como demonstrado no c√≥digo abaixo, voc√™ pode comparar duas tuplas de tipo `(String, Int)` porque os valores `String` e `Int` podem ser comparados usando o operador `<`. Em contraste, duas tuplas do tipo `(String, Bool)` n√£o podem ser comparadas com o operador `<` porque o operador `<` n√£o pode ser aplicado aos valores `Bool`.

```swift
("azul", -1) < ("roxo", 1)        // OK, avaliado como verdadeiro
("azul", false) < ("roxo", true)  // Erro porque < n√£o pode comparar valores booleanos
```

<Callout title="Nota">
  A biblioteca padr√£o do Swift inclui operadores de compara√ß√£o de tuplas para
  tuplas com menos de sete elementos. Para comparar tuplas com sete ou mais
  elementos, voc√™ mesmo deve implementar os operadores de compara√ß√£o.
</Callout>

## Operador Condicional Tern√°rio [#ternary-condition-operator]

O _operador condicional tern√°rio_ √© um operador especial com tr√™s partes, que assume a forma de `pergunta ? resposta1 : resposta2`. √â um atalho para avaliar uma das duas express√µes com base no fato de a pergunta ser verdadeira ou falsa. Se a pergunta for verdadeira, ele avalia a resposta1 e retorna seu valor; caso contr√°rio, ele avalia a resposta2 e retorna seu valor.

O operador condicional tern√°rio √© abrevia√ß√£o para o c√≥digo abaixo:

```swift lineNumbers
if question {
  answer1
} else {
  answer2
}
```

Aqui est√° um exemplo, que calcula a altura de uma linha de mesa. A altura da linha deve ser 50 pontos maior do que a altura do conte√∫do se a linha tiver um cabe√ßalho e 20 pontos mais alta se a linha n√£o tiver um cabe√ßalho:

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20) // [!code highlight]
// rowHeight √© igual a 90
```

O exemplo acima √© uma abrevia√ß√£o para o c√≥digo abaixo:

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight: Int

if hasHeader {
  rowHeight = contentHeight + 50
} else {
  rowHeight = contentHeight + 20
}
```

O primeiro exemplo do uso do operador condicional tern√°rio significa que `rowHeight` pode ser definido para o valor correto em uma √∫nica linha de c√≥digo, que √© mais conciso do que o c√≥digo usado no segundo exemplo.

O operador condicional tern√°rio fornece uma abrevia√ß√£o eficiente para decidir qual das duas express√µes considerar. No entanto, use o operador condicional tern√°rio com cuidado. Sua concis√£o pode levar a um c√≥digo dif√≠cil de ler se usado em excesso. Evite combinar v√°rias inst√¢ncias do operador condicional tern√°rio em uma instru√ß√£o composta.

## Operador Nil-Coalescing [#nil-coalescing-operator]

O _operador de nil-coalescing_ (`a ?? b{:swift}`) desembrulha um opcional `a` se ele contiver um valor, ou retorna um valor padr√£o `b` se `a` for nulo. A express√£o `a` √© sempre de um tipo opcional. A express√£o `b` deve corresponder ao tipo armazenado dentro de `a`.

O operador nil-coalescing √© abrevia√ß√£o para o c√≥digo abaixo:

```swift
a != nil ? a! : b
```

O c√≥digo acima usa o operador condicional tern√°rio e o desembrulhamento for√ßado (`a!`) para acessar o valor envolvido dentro de `a` quando `a` n√£o √© nulo, e para retornar `b` caso contr√°rio. O operador nil-coalescing fornece uma maneira mais elegante de encapsular essa verifica√ß√£o condicional e desembrulhamento em uma forma concisa e leg√≠vel.

<Callout title="Nota">
  Se o valor de `a` n√£o for nulo, o valor de `b` n√£o √© avaliado. Isso √©
  conhecido como avalia√ß√£o de curto-circuito.
</Callout>

O exemplo abaixo usa o operador nil-coalescing para escolher entre um nome de cor padr√£o e um nome de cor opcional definido pelo usu√°rio:

```swift
let defaultColorName = "vermelho"
var userDefinedColorName: String? // padr√£o √© nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName √© nil, ent√£o colorNameToUse √© definido como padr√£o "vermelho"
```

A vari√°vel `userDefinedColorName` √© definida como uma `String` opcional, com um valor padr√£o de `nil`. Como `userDefinedColorName` √© de um tipo opcional, voc√™ pode usar o operador nil-coalescing para considerar seu valor. No exemplo acima, o operador √© usado para determinar um valor inicial para uma vari√°vel `String` chamada `colorNameToUse`. Como `userDefinedColorName` √© nil, a express√£o `userDefinedColorName ?? defaultColorName{:swift}` retorna o valor de `defaultColorName`, ou "vermelho".

Se voc√™ atribuir um valor n√£o nulo a `userDefinedColorName` e executar a verifica√ß√£o do operador nil-coalescing novamente, o valor envolvido dentro do `userDefinedColorName` ser√° usado em vez do padr√£o:

```swift
userDefinedColorName = "verde"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName n√£o √© nil, ent√£o colorNameToUse √© definido como "verde"
```

## Operadores de Intervalo [#range-operators]

O Swift inclui v√°rios _operadores de intervalo_, que s√£o atalhos para expressar um intervalo de valores.

### Operador de intervalo fechado [#closed-range-operator]

O operador de intervalo fechado (`a...b{:swift}`) define um intervalo que vai de `a` a `b` e inclui os valores `a` e `b`. O valor de `a` n√£o deve ser maior que `b`.

O operador de intervalo fechado √© √∫til ao iterar sobre um intervalo no qual voc√™ deseja que todos os valores sejam usados, como com um loop `for-in`:

```swift
// [!code focus:3]
for index in 1...5 { // [!code word:1...5]
  print("\(index) vezes 5 √© \(index * 5)")
}
// 1 vezes 5 √© 5
// 2 vezes 5 √© 10
// 3 vezes 5 √© 15
// 4 vezes 5 √© 20
// 5 vezes 5 √© 25
```

Para mais sobre loops `for-in`, consulte [Fluxo de Controle](/docs/language-guide/control-flow).

### Operador de intervalo semi-aberto [#half-open-range-operator]

O operador de intervalo semi-aberto (`a..<b{:swift}`) define um intervalo que vai de `a` a `b`, mas n√£o inclui `b`. Diz-se que est√° meio aberto porque cont√©m seu primeiro valor, mas n√£o seu valor final. Assim como no operador de intervalo fechado, o valor de `a` n√£o deve ser maior que `b`. Se o valor de `a` for igual a `b`, ent√£o o intervalo resultante estar√° vazio.

Intervalos semiabertos s√£o particularmente √∫teis quando voc√™ trabalha com listas baseadas em zero, como matrizes, onde √© √∫til contar at√© (mas n√£o incluir) o comprimento da lista:

```swift lineNumbers
// [!code focus:5]
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count { // [!code word:0..<count]
  print("Pessoa \(i + 1) se chama \(names[i])")
}
// Pessoa 1 se chama Anna
// Pessoa 2 se chama Alex
// Pessoa 3 se chama Brian
// Pessoa 4 se chama Jack
```

{/* TODO: Add link to arrays */}
Observe que a matriz cont√©m quatro itens, mas `0..<a` contagem s√≥ conta at√© 3 (o √≠ndice do √∫ltimo item na matriz), porque √© um intervalo semiaberto. Para mais sobre matrizes, [Arrays]().

### Intervalos unilaterais [#one-sided-ranges]

O operador de intervalo fechado tem uma forma alternativa para intervalos que continuam o m√°ximo poss√≠vel em uma dire√ß√£o - por exemplo, um intervalo que inclui todos os elementos de uma matriz do √≠ndice 2 at√© o final da matriz. Nesses casos, voc√™ pode omitir o valor de um lado do operador de intervalo. Esse tipo de intervalo √© chamado de intervalo unilateral porque o operador tem um valor em apenas um lado. Por exemplo:

```swift lineNumbers
// [!code focus:3]
for name in names[2...] { // [!code word:2...]
  print(name)
}
// Brian
// Jack
// [!code focus:3]

for name in names[...2] { // [!code word:...2]
  print(name)
}
// Anna
// Alex
// Brian
```

O operador de intervalo semi-aberto tamb√©m tem uma forma unilateral que √© escrita apenas com seu valor final. Assim como quando voc√™ inclui um valor em ambos os lados, o valor final n√£o faz parte do intervalo. Por exemplo:

```swift lineNumbers
// [!code focus:3]
for name in names[..<2] { // [!code word:..<2]
  print(name)
}
// Anna
// Alex
```

Intervalos unilaterais podem ser usados em outros contextos, n√£o apenas em subscritos. Voc√™ n√£o pode iterar sobre um intervalo unilateral que omite um primeiro valor, porque n√£o est√° claro onde a itera√ß√£o deve come√ßar. Voc√™ pode iterar sobre um intervalo unilateral que omite seu valor final; no entanto, como o intervalo continua indefinidamente, certifique-se de adicionar uma condi√ß√£o final expl√≠cita para o loop. Voc√™ tamb√©m pode verificar se um intervalo unilateral cont√©m um valor espec√≠fico, como mostrado no c√≥digo abaixo.

```swift lineNumbers
let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
```

## Operadores L√≥gicos [#logical-operators]

_Operadores l√≥gicos_ modificam ou combinam os valores l√≥gicos booleanos verdadeiro e falso. O Swift suporta os tr√™s operadores l√≥gicos padr√£o encontrados em linguagens baseadas em C:

- NOT (`!a`)
- AND (`a && b`)
- OR (`a || b`)

### Operador l√≥gico NOT [#logical-not-operator]

O operador l√≥gico NOT (`!a`) inverte um valor booleano para que verdadeiro se torne falso e falso se torne verdadeiro.

O operador l√≥gico NOT √© um operador de prefixo e aparece imediatamente antes do valor em que opera, sem nenhum espa√ßo em branco. Pode ser lido como ‚Äún√£o um‚Äù, como visto no exemplo a seguir:

```swift lineNumbers
let allowedEntry = false
if !allowedEntry {
  print("ACESSO NEGADO")
}
```

A frase `if !allowedEntry{:swift}` pode ser lida como ‚Äúse a entrada n√£o permitir‚Äù. A linha subsequente s√≥ √© executada se ‚Äúentrada n√£o permitida‚Äù for verdadeira; ou seja, se a entrada permitida for falsa.

Como neste exemplo, a escolha cuidadosa de constantes booleanas e nomes de vari√°veis pode ajudar a manter o c√≥digo leg√≠vel e conciso, evitando negativos duplos ou declara√ß√µes l√≥gicas confusas.

### Operador l√≥gico AND [#logical-and-operator]

O operador l√≥gico AND (`a && b`) cria express√µes l√≥gicas onde ambos os valores devem ser verdadeiros para que a express√£o geral tamb√©m seja verdadeira.

Se qualquer um dos valores for falso, a express√£o geral tamb√©m ser√° falsa. Na verdade, se o primeiro valor for falso, o segundo valor nem ser√° avaliado, porque n√£o pode fazer com que a express√£o geral seja equivalente a verdadeira. Isso √© conhecido como avalia√ß√£o de curto-circuito.

Este exemplo considera dois valores `Bool` e s√≥ permite o acesso se ambos os valores forem verdadeiros:

```swift lineNumbers
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan { // [!code word:&&]
  print("Bem-vindo!")
} else {
  print("ACESSO NEGADO")
}
```

### Operador L√≥gico OR [#logical-or-operator]

O operador l√≥gico OR (`a || b`) √© um operador infixo feito a partir de dois caracteres de tubo adjacentes. Voc√™ o usa para criar express√µes l√≥gicas nas quais apenas um dos dois valores deve ser verdadeiro para que a express√£o geral seja verdadeira.

Como o operador l√≥gico AND acima, o operador l√≥gico OR usa avalia√ß√£o de curto-circuito para considerar suas express√µes. Se o lado esquerdo de uma express√£o l√≥gica OR for verdadeiro, o lado direito n√£o ser√° avaliado, porque n√£o pode alterar o resultado da express√£o geral.

No exemplo abaixo, o primeiro valor `Bool` (`hasDoorKey`) √© falso, mas o segundo valor (`knowsOverridePassword`) √© verdadeiro. Como um valor √© verdadeiro, a express√£o geral tamb√©m √© avaliada como verdadeira, e o acesso √© permitido:

```swift lineNumbers
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword { // [!code word:||]
  print("Bem-vindo")
} else {
  print("ACESSO NEGADO")
}
```

### Combinando Operadores L√≥gicos [#combining-logical-operators]

Voc√™ pode combinar v√°rios operadores l√≥gicos para criar express√µes compostas mais longas:

```swift lineNumbers
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
  print("Bem-vindo")
} else {
  print("ACESSO NEGADO")
}
```

Este exemplo usa v√°rios operadores `&&` e `||` para criar uma express√£o composta mais longa. No entanto, os operadores `&&` e `||` ainda operam em apenas dois valores, ent√£o, na verdade, s√£o tr√™s express√µes menores encadeadas juntas. O exemplo pode ser lido como:

Se inserimos o c√≥digo correto da porta e passamos na varredura da retina, ou se tivermos uma chave de porta v√°lida, ou se soubermos a senha de substitui√ß√£o de emerg√™ncia, ent√£o permita o acesso.

Com base nos valores de `enteredDoorCode`, `passedRetinaScan` e `hasDoorKey`, as duas primeiras subexpress√µes s√£o falsas. No entanto, a senha de substitui√ß√£o de emerg√™ncia √© conhecida, ent√£o a express√£o composta geral ainda √© avaliada como verdadeira.

<Callout title="Nota">
  Os operadores l√≥gicos Swift `&&` e `||` s√£o associativos √† esquerda, o que
  significa que express√µes compostas com v√°rios operadores l√≥gicos avaliam a
  subexpress√£o mais √† esquerda primeiro.
</Callout>

### Par√™nteses expl√≠citos [#explicit-parentheses]

√Äs vezes √© √∫til incluir par√™nteses quando eles n√£o s√£o estritamente necess√°rios, para tornar a inten√ß√£o de uma express√£o complexa mais f√°cil de ler. No exemplo de acesso √† porta acima, √© √∫til adicionar par√™nteses ao redor da primeira parte da express√£o composta para tornar sua inten√ß√£o expl√≠cita:

```swift lineNumbers
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
  print("Bem-vindo")
} else {
  print("ACESSO NEGADO")
}
```

Os par√™nteses deixam claro que os dois primeiros valores s√£o considerados como parte de um estado poss√≠vel separado na l√≥gica geral. A sa√≠da da express√£o composta n√£o muda, mas a inten√ß√£o geral √© mais clara para o leitor. A legibilidade √© sempre preferida √† brevidade; use par√™nteses onde eles ajudam a deixar suas inten√ß√µes claras.
