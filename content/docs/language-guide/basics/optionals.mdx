---
title: Opcionais
description: Eu sou importante, mas as vezes eu não apareço
---

## Opcionais

Você usa _opcionais_ em situações em que um valor pode estar ausente. Um opcional representa duas possibilidades: ou há um valor, e você pode desembrulhar o opcional para acessar esse valor, ou não há nenhum valor.

:::info[Nota]

O conceito de opcionais não existe em C ou Objective-C. A coisa mais próxima no Objective-C é a capacidade de retornar `nil` de um método que, de outra forma, retornaria um objeto, com `nil` significando “a ausência de um objeto válido”. No entanto, isso só funciona para objetos, não funciona para estruturas, tipos C básicos ou valores de enumeração. Para esses tipos, os métodos Objective-C normalmente retornam um valor especial (como `NSNotFound`) para indicar a ausência de um valor. Essa abordagem assume que o chamador do método sabe que há um valor especial para testar e se lembra de verificá-lo. Os opcionais do Swift permitem que você indique a ausência de um valor para _qualquer tipo_, sem a necessidade de constantes especiais.

:::

Aqui está um exemplo de como os opcionais podem ser usados para lidar com a ausência de um valor. O tipo `Int` do Swift tem um inicializador que tenta converter um valor `String` em um valor `Int`. No entanto, nem toda string pode ser convertida em um inteiro. A string "123" pode ser convertida no valor numérico 123, mas a string "hello, world" não tem um valor numérico óbvio para converter.

O exemplo abaixo usa o inicializador para tentar converter uma `String` em um `Int`:

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber é inferido para o tipo "Int?", ou "optional Int"
```

Como o inicializador pode falhar, ele retorna um `Int` opcional, em vez de um `Int`. Um `Int` opcional é escrito como `Int?`, não `Int`. O ponto de interrogação indica que o valor que ele contém é opcional, o que significa que pode conter algum valor `Int`, ou pode não conter nenhum valor. (Não pode conter mais nada, como um valor `Bool` ou um valor `String`. Ou é um `Int`, ou não é nada.)

### `nil`

Você define uma variável opcional para um estado sem valor atribuindo-lhe o valor especial `nil`:

```swift
var serverResponseCode: Int? = 404
// serverResponseCode tem o valor atual do tipo Int de 404
serverResponseCode = nil
// serverResponseCode agora não tem nenhum valor
```

:::info[Nota]

Você não pode usar `nil` com constantes e variáveis não opcionais. Se uma constante ou variável em seu código precisar trabalhar com a ausência de um valor sob certas condições, sempre declare-a como um valor opcional do tipo apropriado.

:::

Se você definir uma variável opcional sem fornecer um valor padrão, a variável será automaticamente definida como `nil` para você:

```swift
var surveyAnswer: String?
// surveyAnswer é automaticamente definida como nil
```

:::info[Nota]

O `nil` de Swift não é o mesmo que o `nil` no Objective-C. No Objective-C, `nil` é um ponteiro para um objeto inexistente. Em Swift, `nil` não é um ponteiro—é a ausência de um valor de um determinado tipo. Opcionais de qualquer tipo podem ser definidos como `nil`, não apenas tipos de objeto.

:::

### Declarações `if` e Desembrulhamento Forçado

Você pode usar uma instrução `if` para descobrir se um opcional contém um valor comparando o opcional com `nil`. Você realiza essa comparação com o operador “igual a” (`==`) ou o operador “não igual a” (`!=`).

Se um opcional tiver um valor, ele será considerado “não igual a” `nil`:

```swift
if convertedNumber != nil {
  print("convertedNumber tem um valor inteiro.") // convertedNumber tem um valor inteiro.
}
```

Quando tiver certeza de que o opcional contém um valor, você pode acessar seu valor subjacente adicionando um ponto de exclamação (`!`) Até o final do nome do opcional. O ponto de exclamação efetivamente diz: “Eu sei que este opcional definitivamente tem um valor, por favor, use-o.” Isso é conhecido como desembrulhamento forçado do valor do opcional:

```swift
if convertedNumber != nil {
  print("convertedNumber tem um valor inteiro de \(convertedNumber!).") // convertedNumber tem um valor inteiro de \(convertedNumber!).
}
```

Para mais sobre a instrução if, consulte [Fluxo de Controle](../control-flow/index.mdx).

:::info[Nota]

Tentando usar `!` Para acessar um valor opcional inexistente aciona um erro de tempo de execução. Sempre certifique-se de que um opcional contenha um valor diferente de nulo antes de usar `!` Para forçar o desembrulhar seu valor.

:::

### Ligação Opcional

Você usa a _ligação opcional_ para descobrir se um opcional contém um valor e, em caso afirmativo, para disponibilizar esse valor como uma constante ou variável temporária. A ligação opcional pode ser usada com instruções `if` e `while` para verificar um valor dentro de um opcional e para extrair esse valor em uma constante ou variável, como parte de uma única ação. As instruções `if` e `while` são descritas com mais detalhes no [Fluxo de Controle](../control-flow/index.mdx).

Escreva uma ligação opcional para uma instrução `if` da seguinte forma:

```swift
// [!code word:constantName]
// [!code word:someOptional]
// [!code word:statements]
if let constantName = someOptional {
  statements
}
```

Você pode reescrever o exemplo `possibleNumber` da seção [Opcionais](./optionals.mdx) para usar a vinculação opcional em vez de desembrulhamento forçado:

```swift lineNumbers
if let actualNumber = Int(possibleNumber) {
  print("A string \"\(possibleNumber)\" tem um valor inteiro de \(actualNumber)")
} else {
  print("A string \"\(possibleNumber)\" não pode ser convertida para um inteiro")
}

// Retorna: A string "123" tem um valor inteiro de 123
```

Este código pode ser lido como:

“Se o `Int` opcional retornado por `Int(possibleNumber){:swift}` contiver um valor, defina uma nova constante chamada `actualNumber` para o valor contido no opcional.”

Se a conversão for bem-sucedida, a constante `actualNumber` ficará disponível para uso no primeiro ramo da instrução `if`. Já foi inicializado com o valor contido no opcional e, portanto, você não usa o sufixo `!` para acessar seu valor. Neste exemplo, `actualNumber` é simplesmente usado para imprimir o resultado da conversão.

Se você não precisar se referir à constante ou variável original e opcional depois de acessar o valor que ela contém, poderá usar o mesmo nome para a nova constante ou variável:

```swift
let myNumber = Int(possibleNumber) // Aqui, myNumber é um Int opcional
if let myNumber = myNumber {
  // Aqui, myNumber é obrigatoriamente Int
  print("Meu numero é \(myNumber)")
}
```

Este código começa verificando se `myNumber` contém um valor, assim como o código no exemplo anterior. Se `myNumber` tiver um valor, o valor de uma nova constante chamada `myNumber` é definido para esse valor. Dentro do corpo da instrução `if`, escrever `myNumber` refere-se a essa nova constante não opcional. Antes do início da instrução `if` e após seu fim, escrever `myNumber` refere-se à constante inteira opcional.

Como esse tipo de código é tão comum, você pode usar uma ortografia mais curta para desembrulhar um valor opcional: escreva apenas o nome da constante ou variável que você está desembrulhando. A nova constante ou variável não embrulhada usa implicitamente o mesmo nome que o valor opcional.

```swift
if let myNumber {
    print("Meu numero é \(myNumber)")
}
```

Você pode usar constantes e variáveis com ligação opcional. Se você quisesse manipular o valor de `myNumber` dentro do primeiro ramo da instrução `if`, você poderia escrever `if var myNumber{:swift}` em vez disso, e o valor contido no opcional seria disponibilizado como uma variável em vez de uma constante. As alterações que você faz no `myNumber` dentro do corpo da instrução `if` se aplicam apenas a essa variável local, não à constante ou variável original e opcional que você desembrulhou.

Você pode incluir quantas ligações opcionais e condições booleanas precisar em uma única instrução `if`, separadas por vírgulas. Se qualquer um dos valores nas ligações opcionais for nulo ou qualquer condição booleana for avaliada como falsa, a condição da instrução `if` inteira é considerada falsa. As seguintes declarações `if` são equivalentes:

```swift lineNumbers
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 { // [!code focus]
  print("\(firstNumber) < \(secondNumber) < 100") // 4 < 42 < 100
}

// [!code focus:3]
if let firstNumber = Int("4") {
  if let secondNumber = Int("42") {
    if firstNumber < secondNumber && secondNumber < 100 {
      print("\(firstNumber) < \(secondNumber) < 100") // 4 < 42 < 100
    }
  }
}
```

:::info[Nota]

Constantes e variáveis criadas com ligação opcional em uma instrução `if` estão disponíveis apenas dentro do corpo da instrução `if`. Em contraste, as constantes e variáveis criadas com uma instrução de guarda estão disponíveis nas linhas de código que seguem a instrução de guarda, conforme descrito em [Saída Antecipada]().

:::

### Opcionais implicitamente desembrulhados

Conforme descrito acima, os opcionais indicam que uma constante ou variável pode ter “nenhum valor”. Os opcionais podem ser verificados com uma instrução `if` para ver se existe um valor e podem ser desembrulhados condicionalmente com ligação opcional para acessar o valor do opcional, se existir.

Às vezes fica claro na estrutura de um programa que um opcional sempre terá um valor, depois que esse valor for definido pela primeira vez. Nesses casos, é útil remover a necessidade de verificar e desembrulhar o valor do opcional toda vez que for acessado, porque pode-se assumir com segurança que tem um valor o tempo todo.

Esses tipos de opcionais são definidos como opcionais implicitamente desembrulhados. Você escreve um opcional implicitamente desembrulhado colocando um ponto de exclamação (`String!`) Em vez de um ponto de interrogação (`String?`) Após o tipo que você deseja tornar opcional. Em vez de colocar um ponto de exclamação após o nome do opcional quando você o usa, você coloca um ponto de exclamação após o tipo do opcional quando o declara.

Opcionais implicitamente desembrulhados são úteis quando o valor de um opcional é confirmado para existir imediatamente após o opcional ser definido pela primeira vez e podem definitivamente ser assumidos como existindo em todos os pontos depois disso. O uso principal de opcionais implicitamente desembrulhados no Swift é durante a inicialização da classe, conforme descrito em [Referências não pertencentes e Propriedades Opcionais Implicitamente Desembrulhadas]().

Um opcional implicitamente desembrulhado é um opcional normal nos bastidores, mas também pode ser usado como um valor não opcional, sem a necessidade de desembrulhar o valor opcional toda vez que for acessado. O exemplo a seguir mostra a diferença de comportamento entre uma string opcional e uma string opcional implicitamente desembrulhada ao acessar seu valor agrupado como uma `String` explícita:

```swift lineNumbers
let possibleString: String? = "Uma string opcional."
let forcedString: string = possibleString! // Requer um ponto de exclamação

let assumedString: String! = "Uma string opcional implicitamente desembrulhada."
let implicitString: String = assumedString // Não precisa de ponto de exclamação
```

Você pode pensar em um opcional implicitamente desembrulhado como dando permissão para que o opcional seja desembrulhado à força, se necessário. Quando você usa um valor opcional implicitamente desembrulhado, o Swift primeiro tenta usá-lo como um valor opcional comum; se não puder ser usado como um opcional, o Swift desembrulha à força o valor. No código acima, o valor opcional `assumedString` é desembrulhado à força antes de atribuir seu valor a `implicitString` porque `implicitString` tem um tipo de `String` explícito e não opcional. No código abaixo, `optionalString` não tem um tipo explícito, então é um opcional comum.

```swift
let optionalString = assumedString
// O tipo de optionalString é "String?" E assumedString não é desembrulhado à força.
```

Se um opcional implicitamente desembrulhado for nulo e você tentar acessar seu valor agrupado, você acionará um erro de tempo de execução. O resultado é exatamente o mesmo que se você colocasse um ponto de exclamação após um opcional normal que não contenha um valor.

Você pode verificar se um opcional implicitamente desembrulhado é nulo da mesma forma que você verifica um opcional normal:

```swift
if assumedString != nil {
  print(assumedString!) // Uma string opcional implicitamente desembrulhada.
}
```

Você também pode usar um opcional implicitamente desembrulhado com ligação opcional, para verificar e desembrulhar seu valor em uma única instrução:

```swift
if let definiteString = assumedString {
  print(definiteString) // Uma string opcional implicitamente desembrulhada.
}
```

:::info[Nota]

Não use um opcional implicitamente desembrulhado quando houver a possibilidade de uma variável se tornar nula em um ponto posterior. Sempre use um tipo opcional normal se precisar verificar um valor nulo durante a vida útil de uma variável.

:::
